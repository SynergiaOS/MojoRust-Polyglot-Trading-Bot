# =============================================================================
# Core Data Types for AI-Powered Memecoin Trading Bot
# =============================================================================

from time import time
from collections import Dict
from json import loads, dumps

# =============================================================================
# Trading Enums
# =============================================================================

enum TradingAction:
    BUY
    SELL
    HOLD

enum MarketRegime:
    TRENDING_UP
    TRENDING_DOWN
    RANGING
    VOLATILE

enum RiskLevel:
    LOW
    MEDIUM
    HIGH
    CRITICAL

enum SignalSource:
    RSI_SUPPORT
    ARBITRAGE
    MOMENTUM
    MEAN_REVERSION
    AI_SENTIMENT

# =============================================================================
# Trading Signal
# =============================================================================

@value
struct TradingSignal:
    """
    Represents a trading signal generated by a strategy
    """
    var symbol: String
    var action: TradingAction
    var confidence: Float  # 0.0 to 1.0
    var timeframe: String
    var timestamp: Float
    var price_target: Float
    var stop_loss: Float
    var volume: Float
    var liquidity: Float
    var rsi_value: Float
    var support_level: Float
    var resistance_level: Float
    var signal_source: SignalSource
    var metadata: Dict[String, Any]
    var sentiment_score: Float  # -1.0 to 1.0 (filled by AI)
    var ai_analysis: Any  # SentimentAnalysis struct

    fn __init__(
        symbol: String,
        action: TradingAction,
        confidence: Float,
        timeframe: String,
        timestamp: Float = time(),
        price_target: Float = 0.0,
        stop_loss: Float = 0.0,
        volume: Float = 0.0,
        liquidity: Float = 0.0,
        rsi_value: Float = 0.0,
        support_level: Float = 0.0,
        resistance_level: Float = 0.0,
        signal_source: SignalSource = SignalSource.RSI_SUPPORT,
        metadata: Dict[String, Any] = {}
    ):
        self.symbol = symbol
        self.action = action
        self.confidence = max(0.0, min(1.0, confidence))  # Clamp to [0, 1]
        self.timeframe = timeframe
        self.timestamp = timestamp
        self.price_target = price_target
        self.stop_loss = stop_loss
        self.volume = volume
        self.liquidity = liquidity
        self.rsi_value = rsi_value
        self.support_level = support_level
        self.resistance_level = resistance_level
        self.signal_source = signal_source
        self.metadata = metadata
        self.sentiment_score = 0.0  # Will be filled by AI analysis
        self.ai_analysis = None

    fn to_dict(self) -> Dict[String, Any]:
        """Convert signal to dictionary for serialization"""
        return {
            "symbol": self.symbol,
            "action": str(self.action),
            "confidence": self.confidence,
            "timeframe": self.timeframe,
            "timestamp": self.timestamp,
            "price_target": self.price_target,
            "stop_loss": self.stop_loss,
            "volume": self.volume,
            "liquidity": self.liquidity,
            "rsi_value": self.rsi_value,
            "support_level": self.support_level,
            "resistance_level": self.resistance_level,
            "signal_source": str(self.signal_source),
            "metadata": self.metadata,
            "sentiment_score": self.sentiment_score
        }

    fn __str__(self) -> String:
        """String representation for logging"""
        return (f"TradingSignal({self.symbol}, {self.action}, "
                f"conf={self.confidence:.2f}, timeframe={self.timeframe}, "
                f"target={self.price_target:.6f}, stop={self.stop_loss:.6f})")

# =============================================================================
# Market Data
# =============================================================================

@value
struct SocialMetrics:
    """
    Social media metrics for a token
    """
    var twitter_mentions: Int
    var telegram_members: Int
    var discord_members: Int
    var reddit_posts: Int
    var social_volume: Float
    var social_sentiment: Float  # -1.0 to 1.0

    fn __init__(
        twitter_mentions: Int = 0,
        telegram_members: Int = 0,
        discord_members: Int = 0,
        reddit_posts: Int = 0,
        social_volume: Float = 0.0,
        social_sentiment: Float = 0.0
    ):
        self.twitter_mentions = twitter_mentions
        self.telegram_members = telegram_members
        self.discord_members = discord_members
        self.reddit_posts = reddit_posts
        self.social_volume = social_volume
        self.social_sentiment = social_sentiment

@value
struct BlockchainMetrics:
    """
    On-chain metrics for a token
    """
    var unique_traders: Int
    var wash_trading_score: Float  # 0.0 to 1.0
    var holder_distribution_score: Float  # 0.0 to 1.0 (1 = well distributed)
    var transaction_frequency: Float
    var large_transactions: Int
    var liquidity_lock_ratio: Float  # 0.0 to 1.0 (1 = fully locked)

    fn __init__(
        unique_traders: Int = 0,
        wash_trading_score: Float = 0.0,
        holder_distribution_score: Float = 0.5,
        transaction_frequency: Float = 0.0,
        large_transactions: Int = 0,
        liquidity_lock_ratio: Float = 0.0
    ):
        self.unique_traders = unique_traders
        self.wash_trading_score = wash_trading_score
        self.holder_distribution_score = holder_distribution_score
        self.transaction_frequency = transaction_frequency
        self.large_transactions = large_transactions
        self.liquidity_lock_ratio = liquidity_lock_ratio

@value
struct MarketData:
    """
    Market data for a token
    """
    var symbol: String
    var current_price: Float
    var volume_24h: Float
    var liquidity_usd: Float
    var timestamp: Float
    var market_cap: Float
    var price_change_24h: Float
    var price_change_1h: Float
    var price_change_5m: Float
    var holder_count: Int
    var transaction_count: Int
    var age_hours: Float
    var social_metrics: SocialMetrics
    var blockchain_metrics: BlockchainMetrics

    fn __init__(
        symbol: String,
        current_price: Float,
        volume_24h: Float,
        liquidity_usd: Float,
        timestamp: Float = time(),
        market_cap: Float = 0.0,
        price_change_24h: Float = 0.0,
        price_change_1h: Float = 0.0,
        price_change_5m: Float = 0.0,
        holder_count: Int = 0,
        transaction_count: Int = 0,
        age_hours: Float = 0.0,
        social_metrics: SocialMetrics = SocialMetrics(),
        blockchain_metrics: BlockchainMetrics = BlockchainMetrics()
    ):
        self.symbol = symbol
        self.current_price = current_price
        self.volume_24h = volume_24h
        self.liquidity_usd = liquidity_usd
        self.timestamp = timestamp
        self.market_cap = market_cap
        self.price_change_24h = price_change_24h
        self.price_change_1h = price_change_1h
        self.price_change_5m = price_change_5m
        self.holder_count = holder_count
        self.transaction_count = transaction_count
        self.age_hours = age_hours
        self.social_metrics = social_metrics
        self.blockchain_metrics = blockchain_metrics

# =============================================================================
# Confluence Analysis
# =============================================================================

@value
struct ConfluenceAnalysis:
    """
    RSI + Support/Resistance confluence analysis result
    """
    var rsi_value: Float
    var rsi_timeframe: String
    var nearest_support: Float
    var nearest_resistance: Float
    var confluence_strength: Float  # 0.0 to 1.0
    var is_oversold: Bool
    var is_overbought: Bool
    var distance_to_support: Float  # Percentage
    var distance_to_resistance: Float  # Percentage

    fn __init__(
        rsi_value: Float = 50.0,
        rsi_timeframe: String = "1m",
        nearest_support: Float = 0.0,
        nearest_resistance: Float = 0.0,
        confluence_strength: Float = 0.0,
        is_oversold: Bool = False,
        is_overbought: Bool = False,
        distance_to_support: Float = 0.0,
        distance_to_resistance: Float = 0.0
    ):
        self.rsi_value = rsi_value
        self.rsi_timeframe = rsi_timeframe
        self.nearest_support = nearest_support
        self.nearest_resistance = nearest_resistance
        self.confluence_strength = max(0.0, min(1.0, confluence_strength))
        self.is_oversold = is_oversold
        self.is_overbought = is_overbought
        self.distance_to_support = distance_to_support
        self.distance_to_resistance = distance_to_resistance

# =============================================================================
# Trading Context
# =============================================================================

@value
struct TradingContext:
    """
    Complete trading context for a symbol
    """
    var symbol: String
    var confluence_analysis: ConfluenceAnalysis
    var market_regime: MarketRegime
    var sentiment_analysis: Any  # SentimentAnalysis struct
    var risk_assessment: RiskAnalysis
    var processing_time: Float
    var timestamp: Float
    var recommended_action: TradingAction

    fn __init__(
        symbol: String,
        confluence_analysis: ConfluenceAnalysis,
        market_regime: MarketRegime,
        sentiment_analysis: Any = None,
        risk_assessment: RiskAnalysis = RiskAnalysis(),
        processing_time: Float = 0.0,
        timestamp: Float = time(),
        recommended_action: TradingAction = TradingAction.HOLD
    ):
        self.symbol = symbol
        self.confluence_analysis = confluence_analysis
        self.market_regime = market_regime
        self.sentiment_analysis = sentiment_analysis
        self.risk_assessment = risk_assessment
        self.processing_time = processing_time
        self.timestamp = timestamp
        self.recommended_action = recommended_action

# =============================================================================
# Risk Analysis
# =============================================================================

@value
struct RiskAnalysis:
    """
    Risk assessment for a token
    """
    var risk_level: RiskLevel
    var confidence: Float
    var risk_factors: List[String]
    var wash_trading_score: Float
    var liquidity_risk_score: Float
    var volatility_score: Float

    fn __init__(
        risk_level: RiskLevel = RiskLevel.MEDIUM,
        confidence: Float = 0.5,
        risk_factors: List[String] = [],
        wash_trading_score: Float = 0.0,
        liquidity_risk_score: Float = 0.0,
        volatility_score: Float = 0.0
    ):
        self.risk_level = risk_level
        self.confidence = max(0.0, min(1.0, confidence))
        self.risk_factors = risk_factors
        self.wash_trading_score = max(0.0, min(1.0, wash_trading_score))
        self.liquidity_risk_score = max(0.0, min(1.0, liquidity_risk_score))
        self.volatility_score = max(0.0, min(1.0, volatility_score))

# =============================================================================
# Sentiment Analysis
# =============================================================================

@value
struct SentimentAnalysis:
    """
    AI-powered sentiment analysis result
    """
    var sentiment_score: Float  # -1.0 to 1.0
    var confidence: Float  # 0.0 to 1.0
    var key_factors: List[String]
    var recommendation: TradingAction
    var social_volume: Float
    var social_sentiment: Float

    fn __init__(
        sentiment_score: Float = 0.0,
        confidence: Float = 0.5,
        key_factors: List[String] = [],
        recommendation: TradingAction = TradingAction.HOLD,
        social_volume: Float = 0.0,
        social_sentiment: Float = 0.0
    ):
        self.sentiment_score = max(-1.0, min(1.0, sentiment_score))
        self.confidence = max(0.0, min(1.0, confidence))
        self.key_factors = key_factors
        self.recommendation = recommendation
        self.social_volume = social_volume
        self.social_sentiment = social_sentiment

# =============================================================================
# Portfolio and Position Management
# =============================================================================

@value
struct Position:
    """
    Single position in the portfolio
    """
    var symbol: String
    var size: Float  # Number of tokens
    var entry_price: Float
    var current_price: Float
    var unrealized_pnl: Float
    var pnl_percentage: Float
    var entry_timestamp: Float
    var stop_loss_price: Float
    var take_profit_price: Float
    var position_id: String

    fn __init__(
        symbol: String,
        size: Float,
        entry_price: Float,
        current_price: Float,
        unrealized_pnl: Float = 0.0,
        pnl_percentage: Float = 0.0,
        entry_timestamp: Float = time(),
        stop_loss_price: Float = 0.0,
        take_profit_price: Float = 0.0,
        position_id: String = ""
    ):
        self.symbol = symbol
        self.size = size
        self.entry_price = entry_price
        self.current_price = current_price
        self.unrealized_pnl = unrealized_pnl
        self.pnl_percentage = pnl_percentage
        self.entry_timestamp = entry_timestamp
        self.stop_loss_price = stop_loss_price
        self.take_profit_price = take_profit_price
        self.position_id = position_id if position_id else f"{symbol}_{int(entry_timestamp)}"

    fn update_pnl(self):
        """Update P&L based on current price"""
        if self.current_price > 0:
            self.unrealized_pnl = (self.current_price - self.entry_price) * self.size
            self.pnl_percentage = (self.current_price - self.entry_price) / self.entry_price

@value
struct Portfolio:
    """
    Portfolio containing multiple positions
    """
    var total_value: Float
    var available_cash: Float
    var positions: Dict[String, Position]
    var daily_pnl: Float
    var total_pnl: Float
    var peak_value: Float
    var trade_count_today: Int
    var last_reset_timestamp: Float

    fn __init__(
        total_value: Float,
        available_cash: Float,
        positions: Dict[String, Position] = {},
        daily_pnl: Float = 0.0,
        total_pnl: Float = 0.0,
        peak_value: Float = 0.0,
        trade_count_today: Int = 0,
        last_reset_timestamp: Float = time()
    ):
        self.total_value = total_value
        self.available_cash = available_cash
        self.positions = positions
        self.daily_pnl = daily_pnl
        self.total_pnl = total_pnl
        self.peak_value = peak_value if peak_value > 0 else total_value
        self.trade_count_today = trade_count_today
        self.last_reset_timestamp = last_reset_timestamp

    fn reset_daily_stats(self):
        """Reset daily statistics (call at midnight UTC)"""
        self.daily_pnl = 0.0
        self.trade_count_today = 0
        self.last_reset_timestamp = time()

    fn get_position_count(self) -> Int:
        """Get number of open positions"""
        return len(self.positions)

    fn get_position_value(self) -> Float:
        """Get total value of all positions"""
        total = 0.0
        for position in self.positions.values():
            total += position.current_price * position.size
        return total

    def update_total_value(self):
        """Update total portfolio value"""
        position_value = self.get_position_value()
        self.total_value = self.available_cash + position_value

        # Update peak value
        if self.total_value > self.peak_value:
            self.peak_value = self.total_value

# =============================================================================
# Risk Management
# =============================================================================

@value
struct RiskApproval:
    """
    Risk manager approval for a trade
    """
    var approved: Bool
    var reason: String
    var position_size: Float  # In SOL
    var stop_loss_price: Float
    var max_position_size: Float
    var expected_risk_reward_ratio: Float

    fn __init__(
        approved: Bool = False,
        reason: String = "",
        position_size: Float = 0.0,
        stop_loss_price: Float = 0.0,
        max_position_size: Float = 0.0,
        expected_risk_reward_ratio: Float = 0.0
    ):
        self.approved = approved
        self.reason = reason
        self.position_size = position_size
        self.stop_loss_price = stop_loss_price
        self.max_position_size = max_position_size
        self.expected_risk_reward_ratio = expected_risk_reward_ratio

# =============================================================================
# Execution
# =============================================================================

@value
struct ExecutionResult:
    """
    Result of a trade execution
    """
    var success: Bool
    var tx_hash: String
    var executed_price: Float
    var requested_price: Float
    var slippage_percentage: Float
    var execution_time_ms: Float
    var gas_cost: Float
    var error_message: String

    fn __init__(
        success: Bool = False,
        tx_hash: String = "",
        executed_price: Float = 0.0,
        requested_price: Float = 0.0,
        slippage_percentage: Float = 0.0,
        execution_time_ms: Float = 0.0,
        gas_cost: Float = 0.0,
        error_message: String = ""
    ):
        self.success = success
        self.tx_hash = tx_hash
        self.executed_price = executed_price
        self.requested_price = requested_price
        self.slippage_percentage = slippage_percentage
        self.execution_time_ms = execution_time_ms
        self.gas_cost = gas_cost
        self.error_message = error_message

    def calculate_slippage(self):
        """Calculate slippage percentage"""
        if self.requested_price > 0 and self.executed_price > 0:
            self.slippage_percentage = abs(self.executed_price - self.requested_price) / self.requested_price * 100.0

# =============================================================================
# API Client Types
# =============================================================================

@value
struct TokenMetadata:
    """
    Token metadata from Helius
    """
    var address: String
    var name: String
    var symbol: String
    var decimals: Int
    var supply: Float
    var holder_count: Int
    var creation_timestamp: Float
    var creator: String
    var image_url: String
    var description: String

    fn __init__(
        address: String = "",
        name: String = "",
        symbol: String = "",
        decimals: Int = 0,
        supply: Float = 0.0,
        holder_count: Int = 0,
        creation_timestamp: Float = 0.0,
        creator: String = "",
        image_url: String = "",
        description: String = ""
    ):
        self.address = address
        self.name = name
        self.symbol = symbol
        self.decimals = decimals
        self.supply = supply
        self.holder_count = holder_count
        self.creation_timestamp = creation_timestamp
        self.creator = creator
        self.image_url = image_url
        self.description = description

@value
struct TradingPair:
    """
    Trading pair information from DexScreener
    """
    var address: String
    var symbol: String
    var price: Float
    var volume_24h: Float
    var volume_5m: Float
    var volume_1h: Float
    var volume_6h: Float
    var liquidity_usd: Float
    var market_cap: Float
    var price_change_24h: Float
    var price_change_5m: Float
    var price_change_1h: Float
    var transaction_count: Int
    var dex_name: String
    var pair_address: String
    var base_token_address: String
    var quote_token_address: String

    fn __init__(
        address: String = "",
        symbol: String = "",
        price: Float = 0.0,
        volume_24h: Float = 0.0,
        volume_5m: Float = 0.0,
        volume_1h: Float = 0.0,
        volume_6h: Float = 0.0,
        liquidity_usd: Float = 0.0,
        market_cap: Float = 0.0,
        price_change_24h: Float = 0.0,
        price_change_5m: Float = 0.0,
        price_change_1h: Float = 0.0,
        transaction_count: Int = 0,
        dex_name: String = "",
        pair_address: String = "",
        base_token_address: String = "",
        quote_token_address: String = ""
    ):
        self.address = address
        self.symbol = symbol
        self.price = price
        self.volume_24h = volume_24h
        self.volume_5m = volume_5m
        self.volume_1h = volume_1h
        self.volume_6h = volume_6h
        self.liquidity_usd = liquidity_usd
        self.market_cap = market_cap
        self.price_change_24h = price_change_24h
        self.price_change_5m = price_change_5m
        self.price_change_1h = price_change_1h
        self.transaction_count = transaction_count
        self.dex_name = dex_name
        self.pair_address = pair_address
        self.base_token_address = base_token_address
        self.quote_token_address = quote_token_address

@value
struct SwapQuote:
    """
    Jupiter swap quote
    """
    var input_mint: String
    var output_mint: String
    var input_amount: Float
    var output_amount: Float
    var price_impact: Float
    var minimum_output: Float
    var routes: List[Any]  # Route information
    var compute_units: Int
    var platform_fees: Float
    var valid_until: Float

    fn __init__(
        input_mint: String = "",
        output_mint: String = "",
        input_amount: Float = 0.0,
        output_amount: Float = 0.0,
        price_impact: Float = 0.0,
        minimum_output: Float = 0.0,
        routes: List[Any] = [],
        compute_units: Int = 0,
        platform_fees: Float = 0.0,
        valid_until: Float = 0.0
    ):
        self.input_mint = input_mint
        self.output_mint = output_mint
        self.input_amount = input_amount
        self.output_amount = output_amount
        self.price_impact = price_impact
        self.minimum_output = minimum_output
        self.routes = routes
        self.compute_units = compute_units
        self.platform_fees = platform_fees
        self.valid_until = valid_until

# =============================================================================
# Error Types
# =============================================================================

enum TradingError:
    API_ERROR
    VALIDATION_ERROR
    EXECUTION_ERROR
    RISK_REJECTED
    INSUFFICIENT_FUNDS
    NETWORK_ERROR
    TIMEOUT_ERROR
    UNKNOWN_ERROR

@value
struct TradingException:
    """
    Custom exception for trading operations
    """
    var error_type: TradingError
    var message: String
    var timestamp: Float
    var context: Dict[String, Any]

    fn __init__(
        error_type: TradingError,
        message: String,
        timestamp: Float = time(),
        context: Dict[String, Any] = {}
    ):
        self.error_type = error_type
        self.message = message
        self.timestamp = timestamp
        self.context = context

    def __str__(self) -> String:
        return f"TradingException({self.error_type}: {self.message})"