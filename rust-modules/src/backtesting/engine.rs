//! Advanced Backtesting Engine
//!
//! This module provides comprehensive backtesting capabilities for the trading bot,
//! supporting all 12 filter strategies with realistic market simulation,
//! transaction cost modeling, and performance analytics.

use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};
use anyhow::{Result, anyhow};
use log::{info, warn, error, debug};
use chrono::{DateTime, Utc, NaiveDateTime};
use uuid::Uuid;

use super::histor_data::{OHLCVData, PoolSnapshot, HistoricalDataCollector, Timeframe};
use crate::arbitrage::{ArbitrageConfig, ArbitrageOpportunity};
use crate::monitoring::metrics;

/// The 12 trading filters to test
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum FilterType {
    // Trend Following Filters
    MovingAverageCrossover,
    MACDSignal,
    RSIOverboughtOversold,

    // Mean Reversion Filters
    BollingerBands,
    StochasticOscillator,
    MeanReversion,

    // Volume-Based Filters
    VolumeBreakout,
    VWAPCross,
    AccumulationDistribution,

    // Volatility Filters
    ATRBreakout,
    VolatilitySqueeze,

    // Price Action Filters
    SupportResistance,
}

impl FilterType {
    pub fn name(&self) -> &'static str {
        match self {
            FilterType::MovingAverageCrossover => "Moving Average Crossover",
            FilterType::MACDSignal => "MACD Signal",
            FilterType::RSIOverboughtOversold => "RSI Overbought/Oversold",
            FilterType::BollingerBands => "Bollinger Bands",
            FilterType::StochasticOscillator => "Stochastic Oscillator",
            FilterType::MeanReversion => "Mean Reversion",
            FilterType::VolumeBreakout => "Volume Breakout",
            FilterType::VWAPCross => "VWAP Cross",
            FilterType::AccumulationDistribution => "Accumulation/Distribution",
            FilterType::ATRBreakout => "ATR Breakout",
            FilterType::VolatilitySqueeze => "Volatility Squeeze",
            FilterType::SupportResistance => "Support/Resistance",
        }
    }

    pub fn all_filters() -> Vec<FilterType> {
        vec![
            FilterType::MovingAverageCrossover,
            FilterType::MACDSignal,
            FilterType::RSIOverboughtOversold,
            FilterType::BollingerBands,
            FilterType::StochasticOscillator,
            FilterType::MeanReversion,
            FilterType::VolumeBreakout,
            FilterType::VWAPCross,
            FilterType::AccumulationDistribution,
            FilterType::ATRBreakout,
            FilterType::VolatilitySqueeze,
            FilterType::SupportResistance,
        ]
    }
}

/// Backtest configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BacktestConfig {
    pub start_date: NaiveDateTime,
    pub end_date: NaiveDateTime,
    pub initial_capital: f64,
    pub max_position_size: f64,
    pub commission_rate: f64,
    pub slippage_rate: f64,
    pub filters_to_test: Vec<FilterType>,
    pub timeframe: Timeframe,
    pub symbols: Vec<String>,
    pub enable_compounding: bool,
    pub risk_free_rate: f64,
    pub benchmark_return: f64,
}

/// Trading signal generated by a filter
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradingSignal {
    pub id: String,
    pub filter_type: FilterType,
    pub timestamp: i64,
    pub symbol: String,
    pub signal_type: SignalType,
    pub confidence: f64,
    pub price: f64,
    pub volume: f64,
    pub stop_loss: Option<f64>,
    pub take_profit: Option<f64>,
    pub metadata: HashMap<String, f64>,
}

/// Signal type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SignalType {
    Buy,
    Sell,
    Hold,
}

/// Trade execution record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Trade {
    pub id: String,
    pub timestamp: i64,
    pub symbol: String,
    pub action: TradeAction,
    pub quantity: f64,
    pub price: f64,
    pub fees: f64,
    pub slippage: f64,
    pub signal_id: Option<String>,
    pub filter_type: Option<FilterType>,
}

/// Trade action
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum TradeAction {
    Buy,
    Sell,
}

/// Portfolio position
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub symbol: String,
    pub quantity: f64,
    pub average_price: f64,
    pub current_price: f64,
    pub unrealized_pnl: f64,
    pub realized_pnl: f64,
    pub timestamp: i64,
}

/// Backtest results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BacktestResults {
    pub filter_type: FilterType,
    pub start_date: NaiveDateTime,
    pub end_date: NaiveDateTime,
    pub initial_capital: f64,
    pub final_capital: f64,
    pub total_return: f64,
    pub annualized_return: f64,
    pub max_drawdown: f64,
    pub sharpe_ratio: f64,
    pub sortino_ratio: f64,
    pub calmar_ratio: f64,
    pub win_rate: f64,
    pub profit_factor: f64,
    pub average_win: f64,
    pub average_loss: f64,
    pub largest_win: f64,
    pub largest_loss: f64,
    pub total_trades: u64,
    pub winning_trades: u64,
    pub losing_trades: u64,
    pub average_trade_duration: f64,
    pub trades: Vec<Trade>,
    pub equity_curve: Vec<(DateTime<Utc>, f64)>,
    pub drawdown_curve: Vec<(DateTime<Utc>, f64)>,
    pub monthly_returns: HashMap<String, f64>,
}

/// Advanced backtesting engine with comprehensive filter testing
pub struct BacktestEngine {
    config: BacktestConfig,
    data_collector: Arc<HistoricalDataCollector>,
    filter_strategies: HashMap<FilterType, Box<dyn FilterStrategy>>,
    portfolio: Arc<RwLock<Portfolio>>,
    backtest_stats: Arc<RwLock<BacktestStats>>,
}

/// Backtest statistics
#[derive(Debug, Default)]
pub struct BacktestStats {
    pub total_signals_generated: u64,
    pub total_trades_executed: u64,
    pub total_fees_paid: f64,
    pub total_slippage: f64,
    pub execution_errors: u64,
    pub backtest_start_time: Option<SystemTime>,
    pub backtest_end_time: Option<SystemTime>,
    pub data_points_processed: u64,
}

/// Portfolio state
#[derive(Debug, Default)]
struct Portfolio {
    cash: f64,
    positions: HashMap<String, Position>,
    equity_history: VecDeque<(i64, f64)>,
    trades: Vec<Trade>,
    signals: Vec<TradingSignal>,
}

/// Filter strategy trait
trait FilterStrategy: Send + Sync {
    fn name(&self) -> FilterType;
    fn generate_signals(&mut self, data: &[OHLCVData]) -> Result<Vec<TradingSignal>>;
    fn update_parameters(&mut self, params: HashMap<String, f64>);
    fn get_parameters(&self) -> HashMap<String, f64>;
}

impl BacktestEngine {
    /// Create new backtest engine
    pub async fn new(config: BacktestConfig, data_collector: Arc<HistoricalDataCollector>) -> Result<Self> {
        let mut filter_strategies: HashMap<FilterType, Box<dyn FilterStrategy>> = HashMap::new();

        // Initialize all filter strategies
        filter_strategies.insert(FilterType::MovingAverageCrossover, Box::new(MACrossover::new()));
        filter_strategies.insert(FilterType::MACDSignal, Box::new(MACDFilter::new()));
        filter_strategies.insert(FilterType::RSIOverboughtOversold, Box::new(RSIFilter::new()));
        filter_strategies.insert(FilterType::BollingerBands, Box::new(BollingerBandsFilter::new()));
        filter_strategies.insert(FilterType::StochasticOscillator, Box::new(StochasticFilter::new()));
        filter_strategies.insert(FilterType::MeanReversion, Box::new(MeanReversionFilter::new()));
        filter_strategies.insert(FilterType::VolumeBreakout, Box::new(VolumeBreakoutFilter::new()));
        filter_strategies.insert(FilterType::VWAPCross, Box::new(VWAPFilter::new()));
        filter_strategies.insert(FilterType::AccumulationDistribution, Box::new(AccDistFilter::new()));
        filter_strategies.insert(FilterType::ATRBreakout, Box::new(ATRFilter::new()));
        filter_strategies.insert(FilterType::VolatilitySqueeze, Box::new(VolatilitySqueezeFilter::new()));
        filter_strategies.insert(FilterType::SupportResistance, Box::new(SupportResistanceFilter::new()));

        let portfolio = Arc::new(RwLock::new(Portfolio {
            cash: config.initial_capital,
            positions: HashMap::new(),
            equity_history: VecDeque::new(),
            trades: Vec::new(),
            signals: Vec::new(),
        }));

        Ok(Self {
            config,
            data_collector,
            filter_strategies,
            portfolio,
            backtest_stats: Arc::new(RwLock::new(BacktestStats::default())),
        })
    }

    /// Run backtest for a single filter
    pub async fn run_backtest(&mut self, filter_type: FilterType) -> Result<BacktestResults> {
        info!("Starting backtest for filter: {}", filter_type.name());

        let start_time = SystemTime::now();
        {
            let mut stats = self.backtest_stats.write().await;
            stats.backtest_start_time = Some(start_time);
        }

        // Reset portfolio state
        self.reset_portfolio().await;

        // Get historical data
        let start_timestamp = self.config.start_date.timestamp();
        let end_timestamp = self.config.end_date.timestamp();

        let all_trades = Vec::new();
        let mut equity_curve = Vec::new();
        let mut drawdown_curve = Vec::new();

        for symbol in &self.config.symbols {
            let ohlcv_data = self.data_collector
                .get_ohlcv_data(symbol, self.config.timeframe, start_timestamp, end_timestamp)
                .await?;

            if ohlcv_data.is_empty() {
                warn!("No data found for symbol: {}", symbol);
                continue;
            }

            // Process data in chunks to avoid memory issues
            let chunk_size = 1000;
            for chunk in ohlcv_data.chunks(chunk_size) {
                self.process_data_chunk(filter_type, chunk).await?;
            }
        }

        // Calculate final results
        let portfolio_snapshot = self.portfolio.read().await;
        let final_equity = self.calculate_total_equity(&portfolio_snapshot).await;
        let trades = portfolio_snapshot.trades.clone();

        let end_time = SystemTime::now();
        let duration = end_time.duration_since(start_time).unwrap_or_default();

        {
            let mut stats = self.backtest_stats.write().await;
            stats.backtest_end_time = Some(end_time);
        }

        let results = self.calculate_performance_metrics(filter_type, &trades, final_equity).await?;

        info!("Backtest completed for {} in {} seconds", filter_type.name(), duration.as_secs());
        metrics::increment_counter("backtests_completed_total", &[("filter", filter_type.name())]);

        Ok(results)
    }

    /// Run backtests for all filters
    pub async fn run_all_backtests(&mut self) -> Result<Vec<BacktestResults>> {
        info!("Starting backtests for all {} filters", self.config.filters_to_test.len());

        let mut all_results = Vec::new();

        for filter_type in &self.config.filters_to_test.clone() {
            match self.run_backtest(*filter_type).await {
                Ok(results) => {
                    all_results.push(results);
                }
                Err(e) => {
                    error!("Backtest failed for filter {}: {}", filter_type.name(), e);
                }
            }
        }

        info!("Completed {} backtests", all_results.len());
        Ok(all_results)
    }

    /// Reset portfolio to initial state
    async fn reset_portfolio(&self) {
        let mut portfolio = self.portfolio.write().await;
        portfolio.cash = self.config.initial_capital;
        portfolio.positions.clear();
        portfolio.equity_history.clear();
        portfolio.trades.clear();
        portfolio.signals.clear();
    }

    /// Process a chunk of OHLCV data
    async fn process_data_chunk(&mut self, filter_type: FilterType, data: &[OHLCVData]) -> Result<()> {
        let strategy = self.filter_strategies.get_mut(&filter_type)
            .ok_or_else(|| anyhow!("Strategy not found for filter: {:?}", filter_type))?;

        // Generate trading signals
        let signals = strategy.generate_signals(data)?;

        // Process each signal
        for signal in signals {
            self.process_trading_signal(signal).await?;
        }

        // Update portfolio equity
        self.update_portfolio_equity(data.last().unwrap().timestamp).await;

        // Update statistics
        {
            let mut stats = self.backtest_stats.write().await;
            stats.data_points_processed += data.len() as u64;
        }

        Ok(())
    }

    /// Process a trading signal
    async fn process_trading_signal(&self, signal: TradingSignal) -> Result<()> {
        // Store signal
        {
            let mut portfolio = self.portfolio.write().await;
            portfolio.signals.push(signal.clone());
        }

        // Generate trade based on signal
        match signal.signal_type {
            SignalType::Buy => {
                self.execute_buy_order(signal).await?;
            }
            SignalType::Sell => {
                self.execute_sell_order(signal).await?;
            }
            SignalType::Hold => {
                // No action required
            }
        }

        // Update statistics
        {
            let mut stats = self.backtest_stats.write().await;
            stats.total_signals_generated += 1;
        }

        Ok(())
    }

    /// Execute buy order
    async fn execute_buy_order(&self, signal: TradingSignal) -> Result<()> {
        let mut portfolio = self.portfolio.write().await;

        // Calculate position size (simplified risk management)
        let risk_amount = portfolio.cash * 0.02; // 2% risk per trade
        let stop_loss_distance = if let Some(sl) = signal.stop_loss {
            (signal.price - sl).abs()
        } else {
            signal.price * 0.02 // Default 2% stop loss
        };

        let position_size = if stop_loss_distance > 0.0 {
            risk_amount / stop_loss_distance
        } else {
            portfolio.cash * 0.1 // Default 10% if no stop loss
        };

        let position_size = position_size.min(self.config.max_position_size);
        let cost = position_size * signal.price;
        let fees = cost * self.config.commission_rate;
        let slippage = cost * self.config.slippage_rate;
        let total_cost = cost + fees + slippage;

        if total_cost <= portfolio.cash {
            // Execute trade
            let trade = Trade {
                id: Uuid::new_v4().to_string(),
                timestamp: signal.timestamp,
                symbol: signal.symbol.clone(),
                action: TradeAction::Buy,
                quantity: position_size,
                price: signal.price,
                fees,
                slippage,
                signal_id: Some(signal.id.clone()),
                filter_type: Some(signal.filter_type),
            };

            // Update portfolio
            portfolio.cash -= total_cost;

            // Update or create position
            let position = portfolio.positions.entry(signal.symbol.clone()).or_insert(Position {
                symbol: signal.symbol.clone(),
                quantity: 0.0,
                average_price: 0.0,
                current_price: signal.price,
                unrealized_pnl: 0.0,
                realized_pnl: 0.0,
                timestamp: signal.timestamp,
            });

            // Calculate new average price
            let total_cost_basis = position.quantity * position.average_price + cost;
            position.quantity += position_size;
            position.average_price = total_cost_basis / position.quantity;
            position.current_price = signal.price;
            position.timestamp = signal.timestamp;

            portfolio.trades.push(trade);

            // Update statistics
            {
                let mut stats = self.backtest_stats.write().await;
                stats.total_trades_executed += 1;
                stats.total_fees_paid += fees;
                stats.total_slippage += slippage;
            }

            debug!("Executed buy order: {} {} @ ${}", position_size, signal.symbol, signal.price);
        }

        Ok(())
    }

    /// Execute sell order
    async fn execute_sell_order(&self, signal: TradingSignal) -> Result<()> {
        let mut portfolio = self.portfolio.write().await;

        if let Some(position) = portfolio.positions.get_mut(&signal.symbol) {
            if position.quantity > 0.0 {
                // Sell entire position
                let proceeds = position.quantity * signal.price;
                let fees = proceeds * self.config.commission_rate;
                let slippage = proceeds * self.config.slippage_rate;
                let net_proceeds = proceeds - fees - slippage;

                // Calculate P&L
                let cost_basis = position.quantity * position.average_price;
                let pnl = net_proceeds - cost_basis;

                // Execute trade
                let trade = Trade {
                    id: Uuid::new_v4().to_string(),
                    timestamp: signal.timestamp,
                    symbol: signal.symbol.clone(),
                    action: TradeAction::Sell,
                    quantity: position.quantity,
                    price: signal.price,
                    fees,
                    slippage,
                    signal_id: Some(signal.id.clone()),
                    filter_type: Some(signal.filter_type),
                };

                // Update portfolio
                portfolio.cash += net_proceeds;
                position.realized_pnl += pnl;

                // Remove position
                portfolio.positions.remove(&signal.symbol);
                portfolio.trades.push(trade);

                // Update statistics
                {
                    let mut stats = self.backtest_stats.write().await;
                    stats.total_trades_executed += 1;
                    stats.total_fees_paid += fees;
                    stats.total_slippage += slippage;
                }

                debug!("Executed sell order: {} {} @ ${}, P&L: ${}",
                       position.quantity, signal.symbol, signal.price, pnl);
            }
        }

        Ok(())
    }

    /// Update portfolio equity
    async fn update_portfolio_equity(&self, timestamp: i64) {
        let mut portfolio = self.portfolio.write().await;
        let total_equity = self.calculate_total_equity(&portfolio);

        portfolio.equity_history.push_back((timestamp, total_equity));

        // Keep only last 10000 points to manage memory
        if portfolio.equity_history.len() > 10000 {
            portfolio.equity_history.pop_front();
        }
    }

    /// Calculate total portfolio equity
    async fn calculate_total_equity(&self, portfolio: &Portfolio) -> f64 {
        let positions_value: f64 = portfolio.positions.values()
            .map(|pos| pos.quantity * pos.current_price)
            .sum();

        portfolio.cash + positions_value
    }

    /// Calculate performance metrics
    async fn calculate_performance_metrics(&self, filter_type: FilterType, trades: &[Trade], final_equity: f64) -> Result<BacktestResults> {
        let portfolio = self.portfolio.read().await;

        // Basic return calculations
        let total_return = (final_equity - self.config.initial_capital) / self.config.initial_capital;
        let duration_days = (self.config.end_date - self.config.start_date).num_days() as f64;
        let annualized_return = if duration_days > 0.0 {
            ((1.0 + total_return).powf(365.0 / duration_days)) - 1.0
        } else {
            0.0
        };

        // Calculate equity curve
        let equity_curve: Vec<(DateTime<Utc>, f64)> = portfolio.equity_history.iter()
            .map(|(timestamp, equity)| (DateTime::from_timestamp(*timestamp, 0).unwrap_or_default(), *equity))
            .collect();

        // Calculate drawdown
        let (max_drawdown, drawdown_curve) = self.calculate_drawdown(&equity_curve);

        // Calculate trade statistics
        let (win_rate, profit_factor, avg_win, avg_loss, largest_win, largest_loss) =
            self.calculate_trade_statistics(trades);

        // Calculate risk-adjusted returns
        let returns: Vec<f64> = equity_curve.windows(2)
            .map(|w| (w[1].1 - w[0].1) / w[0].1)
            .collect();

        let mean_return = returns.iter().sum::<f64>() / returns.len().max(1) as f64;
        let variance = returns.iter().map(|r| (r - mean_return).powi(2)).sum::<f64>() / returns.len().max(1) as f64;
        let std_dev = variance.sqrt();

        let sharpe_ratio = if std_dev > 0.0 {
            (mean_return * 252.0 - self.config.risk_free_rate) / (std_dev * (252.0_f64).sqrt())
        } else {
            0.0
        };

        let downside_std = returns.iter()
            .filter(|r| **r < 0.0)
            .map(|r| r.powi(2))
            .sum::<f64>()
            .sqrt();

        let sortino_ratio = if downside_std > 0.0 {
            (mean_return * 252.0 - self.config.risk_free_rate) / (downside_std * (252.0_f64).sqrt())
        } else {
            0.0
        };

        let calmar_ratio = if max_drawdown > 0.0 {
            annualized_return / max_drawdown
        } else {
            0.0
        };

        // Calculate average trade duration
        let avg_trade_duration = if trades.len() > 1 {
            let total_duration = trades.windows(2)
                .map(|w| w[1].timestamp - w[0].timestamp)
                .sum::<i64>();
            total_duration as f64 / (trades.len() - 1) as f64
        } else {
            0.0
        };

        Ok(BacktestResults {
            filter_type,
            start_date: self.config.start_date,
            end_date: self.config.end_date,
            initial_capital: self.config.initial_capital,
            final_capital: final_equity,
            total_return,
            annualized_return,
            max_drawdown,
            sharpe_ratio,
            sortino_ratio,
            calmar_ratio,
            win_rate,
            profit_factor,
            average_win: avg_win,
            average_loss: avg_loss,
            largest_win,
            largest_loss,
            total_trades: trades.len() as u64,
            winning_trades: trades.iter().filter(|t| matches!(t.action, TradeAction::Sell) && t.quantity > 0.0).count() as u64,
            losing_trades: trades.iter().filter(|t| matches!(t.action, TradeAction::Sell) && t.quantity > 0.0).count() as u64,
            average_trade_duration: avg_trade_duration,
            trades: trades.to_vec(),
            equity_curve,
            drawdown_curve,
            monthly_returns: HashMap::new(), // Would calculate from equity curve
        })
    }

    /// Calculate drawdown
    fn calculate_drawdown(&self, equity_curve: &[(DateTime<Utc>, f64)]) -> (f64, Vec<(DateTime<Utc>, f64)>) {
        let mut peak = self.config.initial_capital;
        let mut max_drawdown = 0.0;
        let mut drawdown_curve = Vec::new();

        for (timestamp, equity) in equity_curve {
            if *equity > peak {
                peak = *equity;
            }
            let drawdown = (peak - *equity) / peak;
            max_drawdown = max_drawdown.max(drawdown);
            drawdown_curve.push((*timestamp, drawdown));
        }

        (max_drawdown, drawdown_curve)
    }

    /// Calculate trade statistics
    fn calculate_trade_statistics(&self, trades: &[Trade]) -> (f64, f64, f64, f64, f64, f64) {
        let mut winning_trades = Vec::new();
        let mut losing_trades = Vec::new();

        // Group trades by symbol and calculate P&L
        let mut positions: HashMap<String, (f64, f64)> = HashMap::new(); // (quantity, total_cost)

        for trade in trades {
            match trade.action {
                TradeAction::Buy => {
                    let entry = positions.entry(trade.symbol.clone()).or_insert((0.0, 0.0));
                    entry.0 += trade.quantity;
                    entry.1 += trade.quantity * trade.price + trade.fees + trade.slippage;
                }
                TradeAction::Sell => {
                    if let Some((quantity, cost_basis)) = positions.get_mut(&trade.symbol) {
                        if *quantity > 0.0 {
                            let sell_proceeds = trade.quantity * trade.price - trade.fees - trade.slippage;
                            let sell_ratio = trade.quantity / *quantity;
                            let allocated_cost = cost_basis * sell_ratio;
                            let pnl = sell_proceeds - allocated_cost;

                            if pnl > 0.0 {
                                winning_trades.push(pnl);
                            } else {
                                losing_trades.push(pnl);
                            }

                            *quantity -= trade.quantity;
                            *cost_basis -= allocated_cost;
                        }
                    }
                }
            }
        }

        let total_trades = winning_trades.len() + losing_trades.len();
        let win_rate = if total_trades > 0 {
            winning_trades.len() as f64 / total_trades as f64
        } else {
            0.0
        };

        let total_wins: f64 = winning_trades.iter().sum();
        let total_losses: f64 = losing_trades.iter().map(|l| l.abs()).sum();
        let profit_factor = if total_losses > 0.0 {
            total_wins / total_losses
        } else {
            if total_wins > 0.0 { f64::INFINITY } else { 0.0 }
        };

        let avg_win = if winning_trades.is_empty() { 0.0 } else { total_wins / winning_trades.len() as f64 };
        let avg_loss = if losing_trades.is_empty() { 0.0 } else { total_losses / losing_trades.len() as f64 };
        let largest_win = winning_trades.iter().fold(0.0, |a, &b| a.max(b));
        let largest_loss = losing_trades.iter().fold(0.0, |a, &b| a.max(b.abs()));

        (win_rate, profit_factor, avg_win, avg_loss, largest_win, largest_loss)
    }

    /// Get backtest statistics
    pub async fn get_backtest_stats(&self) -> BacktestStats {
        self.backtest_stats.read().await.clone()
    }
}

// Filter Strategy Implementations

struct MACrossover {
    short_period: usize,
    long_period: usize,
    prices: VecDeque<f64>,
}

impl MACrossover {
    fn new() -> Self {
        Self {
            short_period: 10,
            long_period: 30,
            prices: VecDeque::new(),
        }
    }
}

impl FilterStrategy for MACrossover {
    fn name(&self) -> FilterType {
        FilterType::MovingAverageCrossover
    }

    fn generate_signals(&mut self, data: &[OHLCVData]) -> Result<Vec<TradingSignal>> {
        let mut signals = Vec::new();

        for candle in data {
            self.prices.push_back(candle.close);
            if self.prices.len() > self.long_period {
                self.prices.pop_front();
            }

            if self.prices.len() >= self.long_period {
                let short_ma: f64 = self.prices.iter().rev().take(self.short_period).sum::<f64>() / self.short_period as f64;
                let long_ma: f64 = self.prices.iter().sum::<f64>() / self.long_period as f64;

                let prev_short_ma: f64 = self.prices.iter().rev().skip(1).take(self.short_period).sum::<f64>() / self.short_period as f64;
                let prev_long_ma: f64 = self.prices.iter().rev().skip(1).sum::<f64>() / self.long_period as f64;

                // Golden cross: short MA crosses above long MA
                if short_ma > long_ma && prev_short_ma <= prev_long_ma {
                    signals.push(TradingSignal {
                        id: Uuid::new_v4().to_string(),
                        filter_type: FilterType::MovingAverageCrossover,
                        timestamp: candle.timestamp,
                        symbol: "test_symbol".to_string(), // Would use actual symbol
                        signal_type: SignalType::Buy,
                        confidence: 0.7,
                        price: candle.close,
                        volume: candle.volume,
                        stop_loss: Some(candle.close * 0.95),
                        take_profit: Some(candle.close * 1.05),
                        metadata: [("short_ma".to_string(), short_ma), ("long_ma".to_string(), long_ma)].into_iter().collect(),
                    });
                }
                // Death cross: short MA crosses below long MA
                else if short_ma < long_ma && prev_short_ma >= prev_long_ma {
                    signals.push(TradingSignal {
                        id: Uuid::new_v4().to_string(),
                        filter_type: FilterType::MovingAverageCrossover,
                        timestamp: candle.timestamp,
                        symbol: "test_symbol".to_string(),
                        signal_type: SignalType::Sell,
                        confidence: 0.7,
                        price: candle.close,
                        volume: candle.volume,
                        stop_loss: None,
                        take_profit: None,
                        metadata: [("short_ma".to_string(), short_ma), ("long_ma".to_string(), long_ma)].into_iter().collect(),
                    });
                }
            }
        }

        Ok(signals)
    }

    fn update_parameters(&mut self, params: HashMap<String, f64>) {
        if let Some(short) = params.get("short_period") {
            self.short_period = *short as usize;
        }
        if let Some(long) = params.get("long_period") {
            self.long_period = *long as usize;
        }
    }

    fn get_parameters(&self) -> HashMap<String, f64> {
        [
            ("short_period".to_string(), self.short_period as f64),
            ("long_period".to_string(), self.long_period as f64),
        ].into_iter().collect()
    }
}

// Mock implementations for other filters (would implement actual strategies)
struct MACDFilter;
impl FilterStrategy for MACDFilter {
    fn name(&self) -> FilterType { FilterType::MACDSignal }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

struct RSIFilter;
impl FilterStrategy for RSIFilter {
    fn name(&self) -> FilterType { FilterType::RSIOverboughtOversold }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

struct BollingerBandsFilter;
impl FilterStrategy for BollingerBandsFilter {
    fn name(&self) -> FilterType { FilterType::BollingerBands }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

struct StochasticFilter;
impl FilterStrategy for StochasticFilter {
    fn name(&self) -> FilterType { FilterType::StochasticOscillator }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

struct MeanReversionFilter;
impl FilterStrategy for MeanReversionFilter {
    fn name(&self) -> FilterType { FilterType::MeanReversion }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

struct VolumeBreakoutFilter;
impl FilterStrategy for VolumeBreakoutFilter {
    fn name(&self) -> FilterType { FilterType::VolumeBreakout }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

struct VWAPFilter;
impl FilterStrategy for VWAPFilter {
    fn name(&self) -> FilterType { FilterType::VWAPCross }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

struct AccDistFilter;
impl FilterStrategy for AccDistFilter {
    fn name(&self) -> FilterType { FilterType::AccumulationDistribution }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

struct ATRFilter;
impl FilterStrategy for ATRFilter {
    fn name(&self) -> FilterType { FilterType::ATRBreakout }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

struct VolatilitySqueezeFilter;
impl FilterStrategy for VolatilitySqueezeFilter {
    fn name(&self) -> FilterType { FilterType::VolatilitySqueeze }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

struct SupportResistanceFilter;
impl FilterStrategy for SupportResistanceFilter {
    fn name(&self) -> FilterType { FilterType::SupportResistance }
    fn generate_signals(&mut self, _data: &[OHLCVData]) -> Result<Vec<TradingSignal>> { Ok(Vec::new()) }
    fn update_parameters(&mut self, _params: HashMap<String, f64>) {}
    fn get_parameters(&self) -> HashMap<String, f64> { HashMap::new() }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::NaiveDate;

    #[tokio::test]
    async fn test_backtest_config_creation() {
        let config = BacktestConfig {
            start_date: NaiveDate::from_ymd_opt(2023, 1, 1).unwrap().and_hms_opt(0, 0, 0).unwrap(),
            end_date: NaiveDate::from_ymd_opt(2023, 12, 31).unwrap().and_hms_opt(23, 59, 59).unwrap(),
            initial_capital: 10000.0,
            max_position_size: 1000.0,
            commission_rate: 0.001,
            slippage_rate: 0.0005,
            filters_to_test: vec![FilterType::MovingAverageCrossover],
            timeframe: Timeframe::OneHour,
            symbols: vec!["SOL".to_string()],
            enable_compounding: true,
            risk_free_rate: 0.02,
            benchmark_return: 0.10,
        };

        assert_eq!(config.initial_capital, 10000.0);
        assert_eq!(config.filters_to_test.len(), 1);
    }

    #[test]
    fn test_filter_type_names() {
        assert_eq!(FilterType::MovingAverageCrossover.name(), "Moving Average Crossover");
        assert_eq!(FilterType::RSIOverboughtOversold.name(), "RSI Overbought/Oversold");
    }

    #[test]
    fn test_all_filters() {
        let filters = FilterType::all_filters();
        assert_eq!(filters.len(), 12);
        assert!(filters.contains(&FilterType::MovingAverageCrossover));
        assert!(filters.contains(&FilterType::SupportResistance));
    }
}