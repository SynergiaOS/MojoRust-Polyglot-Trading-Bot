/*
High-Performance Arbitrage Detection Engine for MojoRust Trading Bot

Implements multiple arbitrage strategies:
1. Triangular Arbitrage: A → B → C → A cycles
2. Cross-DEX Arbitrage: Same token on different DEXes
3. Statistical Arbitrage: Mean reversion and statistical patterns
4. Flash Loan Arbitrage: Atomic arbitrage opportunities

Features:
- Real-time price analysis
- Profit calculation with gas fees
- Slippage estimation
- Risk assessment
- Fast detection algorithms
- Integration with Jupiter Price API
*/

use std::collections::{HashMap, HashSet, VecDeque};
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
use std::sync::{Arc, Mutex, RwLock};
use std::thread;

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use tokio::sync::RwLock as AsyncRwLock;
use tokio::time::interval;
use tracing::{debug, error, info, warn};

// Import SIMD optimizations
use crate::ffi::simd::{
    calculate_triangular_profit_simd, calculate_batch_triangular_profits,
    calculate_spreads_simd, calculate_z_scores_simd, is_simd_available
};

// Core data structures
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenInfo {
    pub address: String,
    pub symbol: String,
    pub name: String,
    pub decimals: u8,
    pub verified: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DexPrice {
    pub dex_name: String,
    pub token_address: String,
    pub price: f64,
    pub liquidity: Option<f64>,
    pub volume_24h: Option<f64>,
    pub timestamp: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceEdge {
    pub from_token: String,
    pub to_token: String,
    pub dex_name: String,
    pub price: f64,
    pub liquidity: f64,
    pub fee_rate: f64,
    pub timestamp: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TriangularOpportunity {
    pub cycle: Vec<String>,           // A → B → C → A
    pub dexes: Vec<String>,           // DEX for each edge
    pub prices: Vec<f64>,            // Prices for each edge
    pub profit_percentage: f64,       // Net profit after fees
    pub estimated_gas_cost: f64,      // SOL gas cost
    pub liquidity_score: f64,        // Minimum liquidity along path
    pub confidence_score: f64,       // Statistical confidence
    pub timestamp: i64,
    pub slippage_estimate: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrossDexOpportunity {
    pub token_address: String,
    pub symbol: String,
    pub buy_dex: String,
    pub sell_dex: String,
    pub buy_price: f64,
    pub sell_price: f64,
    pub spread_percentage: f64,
    pub buy_liquidity: f64,
    pub sell_liquidity: f64,
    pub estimated_gas_cost: f64,
    pub profit_after_gas: f64,
    pub timestamp: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StatisticalOpportunity {
    pub token_address: String,
    pub symbol: String,
    pub current_price: f64,
    pub mean_price: f64,
    pub std_deviation: f64,
    pub z_score: f64,
    pub expected_return: f64,
    pub confidence: f64,
    pub holding_period: Duration,
    pub timestamp: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArbitrageConfig {
    pub min_profit_threshold: f64,      // Minimum profit percentage
    pub max_slippage: f64,              // Maximum acceptable slippage
    pub min_liquidity: f64,             // Minimum liquidity threshold
    pub max_gas_price: f64,             // Maximum gas price in SOL
    pub confidence_threshold: f64,      // Minimum confidence score
    pub scan_interval: Duration,        // Price scan interval
    pub opportunity_timeout: Duration,  // How long opportunities are valid
    pub max_concurrent_trades: usize,   // Maximum concurrent arbitrage trades
    pub risk_tolerance: f64,            // Risk tolerance (0.0-1.0)
}

impl Default for ArbitrageConfig {
    fn default() -> Self {
        Self {
            min_profit_threshold: 0.5,     // 0.5%
            max_slippage: 2.0,            // 2%
            min_liquidity: 10000.0,       // $10,000
            max_gas_price: 0.01,          // 0.01 SOL
            confidence_threshold: 0.7,    // 70%
            scan_interval: Duration::from_millis(500), // 500ms
            opportunity_timeout: Duration::from_secs(30), // 30 seconds
            max_concurrent_trades: 5,
            risk_tolerance: 0.5,          // Medium risk
        }
    }
}

// Statistical models for price prediction
#[derive(Debug)]
pub struct PriceModel {
    pub token_address: String,
    pub prices: VecDeque<f64>,
    pub timestamps: VecDeque<i64>,
    pub mean: f64,
    pub variance: f64,
    pub trend: f64,
    pub volatility: f64,
    pub last_updated: Instant,
}

impl PriceModel {
    pub fn new(token_address: String, window_size: usize) -> Self {
        Self {
            token_address,
            prices: VecDeque::with_capacity(window_size),
            timestamps: VecDeque::with_capacity(window_size),
            mean: 0.0,
            variance: 0.0,
            trend: 0.0,
            volatility: 0.0,
            last_updated: Instant::now(),
        }
    }

    pub fn update(&mut self, price: f64, timestamp: i64) {
        if self.prices.len() >= self.prices.capacity() {
            self.prices.pop_front();
            self.timestamps.pop_front();
        }

        self.prices.push_back(price);
        self.timestamps.push_back(timestamp);
        self.recalculate_statistics();
    }

    fn recalculate_statistics(&mut self) {
        if self.prices.is_empty() {
            return;
        }

        let n = self.prices.len() as f64;

        // Calculate mean
        self.mean = self.prices.iter().sum::<f64>() / n;

        // Calculate variance and standard deviation
        self.variance = self.prices.iter()
            .map(|x| (x - self.mean).powi(2))
            .sum::<f64>() / n;

        // Calculate trend (simple linear regression slope)
        if self.prices.len() >= 2 {
            let x_mean = (self.prices.len() - 1) as f64 / 2.0;
            let mut numerator = 0.0;
            let mut denominator = 0.0;

            for (i, price) in self.prices.iter().enumerate() {
                let x = i as f64;
                numerator += (x - x_mean) * (price - self.mean);
                denominator += (x - x_mean).powi(2);
            }

            self.trend = if denominator > 0.0 { numerator / denominator } else { 0.0 };
        }

        // Calculate volatility (standard deviation of returns)
        if self.prices.len() >= 2 {
            let returns: Vec<f64> = self.prices.iter()
                .zip(self.prices.iter().skip(1))
                .map(|(prev, curr)| (curr - prev) / prev)
                .collect();

            if !returns.is_empty() {
                let mean_return = returns.iter().sum::<f64>() / returns.len() as f64;
                self.volatility = (returns.iter()
                    .map(|r| (r - mean_return).powi(2))
                    .sum::<f64>() / returns.len() as f64).sqrt();
            }
        }

        self.last_updated = Instant::now();
    }

    pub fn predict_next_price(&self) -> f64 {
        if self.prices.is_empty() {
            return 0.0;
        }

        // Simple prediction based on trend
        let current_price = self.prices.back().unwrap_or(&0.0);
        current_price + self.trend
    }

    pub fn get_z_score(&self, price: f64) -> f64 {
        if self.variance > 0.0 {
            (price - self.mean) / self.variance.sqrt()
        } else {
            0.0
        }
    }
}

// Main arbitrage detection engine
pub struct ArbitrageEngine {
    config: ArbitrageConfig,
    token_registry: HashMap<String, TokenInfo>,
    price_graph: HashMap<String, Vec<PriceEdge>>,
    price_models: HashMap<String, PriceModel>,
    active_opportunities: Arc<Mutex<Vec<TriangularOpportunity>>>,
    cross_dex_opportunities: Arc<Mutex<Vec<CrossDexOpportunity>>>,
    statistical_opportunities: Arc<Mutex<Vec<StatisticalOpportunity>>>,
    last_scan: Arc<Mutex<Instant>>,
    is_running: Arc<Mutex<bool>>,
}

impl ArbitrageEngine {
    pub fn new(config: ArbitrageConfig) -> Self {
        Self {
            config,
            token_registry: HashMap::new(),
            price_graph: HashMap::new(),
            price_models: HashMap::new(),
            active_opportunities: Arc::new(Mutex::new(Vec::new())),
            cross_dex_opportunities: Arc::new(Mutex::new(Vec::new())),
            statistical_opportunities: Arc::new(Mutex::new(Vec::new())),
            last_scan: Arc::new(Mutex::new(Instant::now())),
            is_running: Arc::new(Mutex::new(false)),
        }
    }

    pub fn register_token(&mut self, token: TokenInfo) {
        info!("Registering token: {} ({})", token.symbol, token.address);
        self.token_registry.insert(token.address.clone(), token);

        // Initialize price model
        let price_model = PriceModel::new(token.address.clone(), 100); // 100-sample window
        self.price_models.insert(token.address.clone(), price_model);
    }

    pub fn update_price(&mut self, dex_price: DexPrice) {
        debug!("Updating price: {} on {} = {}",
               dex_price.token_address, dex_price.dex_name, dex_price.price);

        // Update price model
        if let Some(model) = self.price_models.get_mut(&dex_price.token_address) {
            model.update(dex_price.price, dex_price.timestamp);
        }

        // Update price graph
        self.update_price_graph(dex_price);
    }

    fn update_price_graph(&mut self, dex_price: DexPrice) {
        // In a real implementation, this would parse DEX-specific pairs
        // For now, we'll create a simplified graph structure

        let token = &dex_price.token_address;

        // Create edges for common pairs (SOL/USDC, USDC/TOKEN, etc.)
        // This is simplified - in reality, we'd parse actual trading pairs
        let sol_address = "So11111111111111111111111111111111111111112";
        let usdc_address = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

        // Update SOL/TOKEN edge
        if token != sol_address {
            let edge = PriceEdge {
                from_token: sol_address.to_string(),
                to_token: token.clone(),
                dex_name: dex_price.dex_name.clone(),
                price: dex_price.price,
                liquidity: dex_price.liquidity.unwrap_or(0.0),
                fee_rate: 0.003, // 0.3% typical DEX fee
                timestamp: dex_price.timestamp,
            };

            self.price_graph
                .entry(sol_address.to_string())
                .or_insert_with(Vec::new)
                .push(edge);
        }

        // Update TOKEN/SOL edge
        if token != sol_address {
            let edge = PriceEdge {
                from_token: token.clone(),
                to_token: sol_address.to_string(),
                dex_name: dex_price.dex_name.clone(),
                price: 1.0 / dex_price.price,
                liquidity: dex_price.liquidity.unwrap_or(0.0),
                fee_rate: 0.003,
                timestamp: dex_price.timestamp,
            };

            self.price_graph
                .entry(token.clone())
                .or_insert_with(Vec::new)
                .push(edge);
        }
    }

    pub async fn scan_arbitrage_opportunities(&mut self) -> Result<usize> {
        let start_time = Instant::now();
        let mut total_opportunities = 0;

        // Scan for triangular arbitrage
        let triangular_count = self.scan_triangular_arbitrage().await?;
        total_opportunities += triangular_count;

        // Scan for cross-DEX arbitrage
        let cross_dex_count = self.scan_cross_dex_arbitrage().await?;
        total_opportunities += cross_dex_count;

        // Scan for statistical arbitrage
        let statistical_count = self.scan_statistical_arbitrage().await?;
        total_opportunities += statistical_count;

        // Update last scan time
        *self.last_scan.lock().unwrap() = Instant::now();

        let scan_duration = start_time.elapsed();
        info!("Arbitrage scan completed: {} opportunities in {:?}",
              total_opportunities, scan_duration);

        Ok(total_opportunities)
    }

    async fn scan_triangular_arbitrage(&mut self) -> Result<usize> {
        let mut opportunities = Vec::new();
        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        // Get all tokens with sufficient edges
        let tokens_with_edges: Vec<String> = self.price_graph
            .keys()
            .filter(|token| {
                self.price_graph.get(*token)
                    .map(|edges| edges.len() >= 2)
                    .unwrap_or(false)
            })
            .cloned()
            .collect();

        for start_token in &tokens_with_edges {
            // Find 2-step cycles: A → B → C → A
            if let Some(edges_from_a) = self.price_graph.get(start_token) {
                for edge_a in edges_from_a {
                    let token_b = &edge_a.to_token;

                    if let Some(edges_from_b) = self.price_graph.get(token_b) {
                        for edge_b in edges_from_b {
                            let token_c = &edge_b.to_token;

                            // Skip if we're back to the start token (need 3 distinct tokens)
                            if token_c == start_token {
                                continue;
                            }

                            // Find edge from C back to A
                            if let Some(edges_from_c) = self.price_graph.get(token_c) {
                                for edge_c in edges_from_c {
                                    if edge_c.to_token == *start_token {
                                        // Found a cycle: A → B → C → A
                                        let opportunity = self.calculate_triangular_opportunity(
                                            start_token, token_b, token_c,
                                            &edge_a, &edge_b, &edge_c,
                                            current_time
                                        );

                                        if let Some(opp) = opportunity {
                                            if self.is_opportunity_valid(&opp) {
                                                opportunities.push(opp);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Update active opportunities
        *self.active_opportunities.lock().unwrap() = opportunities.clone();

        Ok(opportunities.len())
    }

    fn calculate_triangular_opportunity(
        &self,
        token_a: &str,
        token_b: &str,
        token_c: &str,
        edge_a: &PriceEdge,
        edge_b: &PriceEdge,
        edge_c: &PriceEdge,
        timestamp: i64,
    ) -> Option<TriangularOpportunity> {
        // Use SIMD for profit calculation if available
        let gross_profit = if is_simd_available() {
            let prices = [edge_a.price, edge_b.price, edge_c.price];
            let fees = [edge_a.fee_rate, edge_b.fee_rate, edge_c.fee_rate];
            calculate_triangular_profit_simd(&prices, &fees)
        } else {
            // Fallback to scalar calculation
            (1.0 / edge_a.price) * (1.0 / edge_b.price) * (1.0 / edge_c.price) - 1.0
        };

        // Calculate net profit (already includes fees in SIMD version)
        let net_profit = if is_simd_available() {
            gross_profit
        } else {
            // Subtract fees for scalar version
            let total_fees = edge_a.fee_rate + edge_b.fee_rate + edge_c.fee_rate;
            gross_profit - total_fees
        };

        // Estimate gas cost (simplified)
        let estimated_gas_cost = 0.005; // 0.005 SOL typical for 3-hop swap

        // Calculate liquidity score (minimum liquidity along the path)
        let liquidity_score = edge_a.liquidity.min(edge_b.liquidity).min(edge_c.liquidity);

        // Calculate confidence score based on price stability
        let confidence_score = self.calculate_confidence_score(token_a, token_b, token_c);

        // Estimate slippage
        let slippage_estimate = self.estimate_slippage(&[edge_a, edge_b, edge_c]);

        if net_profit > self.config.min_profit_threshold / 100.0 {
            Some(TriangularOpportunity {
                cycle: vec![
                    token_a.to_string(),
                    token_b.to_string(),
                    token_c.to_string(),
                    token_a.to_string(),
                ],
                dexes: vec![
                    edge_a.dex_name.clone(),
                    edge_b.dex_name.clone(),
                    edge_c.dex_name.clone(),
                ],
                prices: vec![edge_a.price, edge_b.price, edge_c.price],
                profit_percentage: net_profit * 100.0,
                estimated_gas_cost,
                liquidity_score,
                confidence_score,
                timestamp,
                slippage_estimate,
            })
        } else {
            None
        }
    }

    async fn scan_cross_dex_arbitrage(&mut self) -> Result<usize> {
        let mut opportunities = Vec::new();
        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        // Group prices by token and DEX
        let mut token_dex_prices: HashMap<String, Vec<(&String, f64, f64)>> = HashMap::new();

        for (token, edges) in &self.price_graph {
            for edge in edges {
                token_dex_prices
                    .entry(edge.to_token.clone())
                    .or_insert_with(Vec::new)
                    .push((&edge.dex_name, edge.price, edge.liquidity));
            }
        }

        // Find arbitrage opportunities between DEXes
        for (token_address, dex_prices) in token_dex_prices {
            if dex_prices.len() < 2 {
                continue;
            }

            // Sort by price to find best buy/sell opportunities
            let mut sorted_prices = dex_prices;
            sorted_prices.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());

            // Use SIMD for spread calculation if available
            let spreads = if is_simd_available() && sorted_prices.len() >= 4 {
                // Extract buy and sell prices for SIMD processing
                let buy_prices: Vec<f64> = sorted_prices.iter().map(|(_, price, _)| *price).collect();
                let sell_prices: Vec<f64> = sorted_prices.iter().rev().map(|(_, price, _)| *price).collect();

                // Calculate spreads using SIMD (we only need first N/2 spreads)
                let min_len = buy_prices.len().min(sell_prices.len());
                let spreads = calculate_spreads_simd(&buy_prices[..min_len], &sell_prices[..min_len]);

                // Convert back to spread percentages and add original percentages
                spreads.iter().enumerate().map(|(i, spread)| {
                    let original_spread = (sorted_prices[i].1 - sorted_prices[sorted_prices.len() - 1 - i].1) / sorted_prices[i].1 * 100.0;
                    if i < spreads.len() { *spread } else { original_spread }
                }).collect()
            } else {
                // Fallback to scalar calculation
                Vec::new()
            };

            // Check each combination for profitable spread
            for i in 0..sorted_prices.len() {
                for j in (i + 1)..sorted_prices.len() {
                    let (buy_dex, buy_price, buy_liquidity) = sorted_prices[i];
                    let (sell_dex, sell_price, sell_liquidity) = sorted_prices[j];

                    let spread_percentage = if !spreads.is_empty() && i < spreads.len() {
                        spreads[i]
                    } else {
                        // Fallback to scalar calculation
                        (sell_price - buy_price) / buy_price * 100.0
                    };

                    if spread_percentage > self.config.min_profit_threshold {
                        let estimated_gas_cost = 0.003; // 0.003 SOL for 2-hop swap
                        let profit_after_gas = spread_percentage - (estimated_gas_cost * 100.0); // Simplified

                        if profit_after_gas > 0.0 {
                            let symbol = self.token_registry
                                .get(token_address)
                                .map(|t| t.symbol.clone())
                                .unwrap_or_else(|| "UNKNOWN".to_string());

                            opportunities.push(CrossDexOpportunity {
                                token_address: token_address.clone(),
                                symbol,
                                buy_dex: buy_dex.clone(),
                                sell_dex: sell_dex.clone(),
                                buy_price,
                                sell_price,
                                spread_percentage,
                                buy_liquidity,
                                sell_liquidity,
                                estimated_gas_cost,
                                profit_after_gas,
                                timestamp: current_time,
                            });
                        }
                    }
                }
            }
        }

        *self.cross_dex_opportunities.lock().unwrap() = opportunities.clone();

        Ok(opportunities.len())
    }

    async fn scan_statistical_arbitrage(&mut self) -> Result<usize> {
        let mut opportunities = Vec::new();
        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        // Collect models with sufficient data for batch processing
        let mut candidate_models: Vec<(&String, &PriceModel)> = self.price_models
            .iter()
            .filter(|(_, model)| model.prices.len() >= 20)
            .collect();

        if is_simd_available() && candidate_models.len() >= 4 {
            // Batch Z-score calculation using SIMD
            let current_prices: Vec<f64> = candidate_models
                .iter()
                .map(|(_, model)| *model.prices.back().unwrap_or(&0.0))
                .collect();

            let means: Vec<f64> = candidate_models
                .iter()
                .map(|(_, model)| model.mean)
                .collect();

            let std_devs: Vec<f64> = candidate_models
                .iter()
                .map(|(_, model)| model.variance.sqrt())
                .collect();

            // Calculate Z-scores in batch using SIMD (process in chunks)
            let mut z_scores = vec![0.0; current_prices.len()];

            for (chunk_start, chunk_prices) in current_prices.chunks(4).enumerate() {
                let chunk_z_scores = calculate_z_scores_simd(
                    chunk_prices,
                    means[chunk_start],
                    std_devs[chunk_start]
                );

                for (i, &z_score) in chunk_z_scores.iter().enumerate() {
                    if chunk_start * 4 + i < z_scores.len() {
                        z_scores[chunk_start * 4 + i] = z_score;
                    }
                }
            }

            // Process results
            for (i, (token_address, model)) in candidate_models.into_iter().enumerate() {
                if i >= z_scores.len() {
                    break;
                }

                let current_price = current_prices[i];
                let z_score = z_scores[i];

                if current_price <= 0.0 {
                    continue;
                }

                // Look for mean reversion opportunities
                let expected_return = if z_score.abs() > 2.0 {
                    // Price is more than 2 standard deviations from mean
                    -z_score * model.volatility * 0.5 // Expected reversion
                } else {
                    0.0
                };

                if expected_return.abs() > self.config.min_profit_threshold / 100.0 {
                    let confidence = (1.0 / (1.0 + z_score.abs())).min(self.config.confidence_threshold);

                    if confidence >= self.config.confidence_threshold {
                        let symbol = self.token_registry
                            .get(token_address)
                            .map(|t| t.symbol.clone())
                            .unwrap_or_else(|| "UNKNOWN".to_string());

                        opportunities.push(StatisticalOpportunity {
                            token_address: token_address.clone(),
                            symbol,
                            current_price,
                            mean_price: model.mean,
                            std_deviation: model.variance.sqrt(),
                            z_score,
                            expected_return: expected_return * 100.0,
                            confidence,
                            holding_period: Duration::from_secs(300), // 5 minutes
                            timestamp: current_time,
                        });
                    }
                }
            }
        } else {
            // Fallback to scalar processing
            for (token_address, model) in &self.price_models {
                if model.prices.len() < 20 {
                    continue; // Need sufficient data for statistical analysis
                }

                let current_price = *model.prices.back().unwrap_or(&0.0);
                if current_price <= 0.0 {
                    continue;
                }

                // Calculate Z-score
                let z_score = model.get_z_score(current_price);

            // Look for mean reversion opportunities
            let expected_return = if z_score.abs() > 2.0 {
                // Price is more than 2 standard deviations from mean
                -z_score * model.volatility * 0.5 // Expected reversion
            } else {
                0.0
            };

            if expected_return.abs() > self.config.min_profit_threshold / 100.0 {
                let confidence = (1.0 / (1.0 + z_score.abs())).min(self.config.confidence_threshold);

                if confidence >= self.config.confidence_threshold {
                    let symbol = self.token_registry
                        .get(token_address)
                        .map(|t| t.symbol.clone())
                        .unwrap_or_else(|| "UNKNOWN".to_string());

                    opportunities.push(StatisticalOpportunity {
                        token_address: token_address.clone(),
                        symbol,
                        current_price,
                        mean_price: model.mean,
                        std_deviation: model.variance.sqrt(),
                        z_score,
                        expected_return: expected_return * 100.0,
                        confidence,
                        holding_period: Duration::from_secs(300), // 5 minutes
                        timestamp: current_time,
                    });
                }
            }
        }

        *self.statistical_opportunities.lock().unwrap() = opportunities.clone();

        Ok(opportunities.len())
    }

    fn calculate_confidence_score(&self, token_a: &str, token_b: &str, token_c: &str) -> f64 {
        let mut total_confidence = 0.0;
        let mut count = 0;

        for token in [token_a, token_b, token_c] {
            if let Some(model) = self.price_models.get(token) {
                if model.prices.len() >= 10 {
                    // Higher confidence for more stable prices (lower volatility)
                    let stability_score = 1.0 / (1.0 + model.volatility);
                    total_confidence += stability_score;
                    count += 1;
                }
            }
        }

        if count > 0 {
            total_confidence / count
        } else {
            0.5 // Default confidence
        }
    }

    fn estimate_slippage(&self, edges: &[&PriceEdge]) -> f64 {
        // Simple slippage estimation based on liquidity
        let total_liquidity: f64 = edges.iter().map(|e| e.liquidity).sum();

        if total_liquidity > 0.0 {
            // Estimate slippage as inversely proportional to liquidity
            (10000.0 / total_liquidity).min(5.0) // Max 5% slippage
        } else {
            2.0 // Default 2% slippage
        }
    }

    /// Batch process triangular arbitrage opportunities using SIMD
    pub fn batch_calculate_triangular_opportunities(
        &self,
        candidates: &[(&String, &String, &String, &PriceEdge, &PriceEdge, &PriceEdge)],
        timestamp: i64,
    ) -> Vec<TriangularOpportunity> {
        if candidates.is_empty() {
            return Vec::new();
        }

        if is_simd_available() && candidates.len() >= 4 {
            // Use SIMD for batch processing
            let mut opportunities = Vec::new();

            // Prepare data for SIMD processing
            let mut batch_data = Vec::with_capacity(candidates.len());
            for (token_a, token_b, token_c, edge_a, edge_b, edge_c) in candidates {
                batch_data.push((
                    edge_a.price, edge_b.price, edge_c.price,
                    edge_a.fee_rate, edge_b.fee_rate, edge_c.fee_rate,
                    token_a, token_b, token_c, edge_a, edge_b, edge_c
                ));
            }

            // Process in chunks for SIMD efficiency
            let chunk_size = 4; // SIMD width
            for chunk in batch_data.chunks(chunk_size) {
                let opportunities_for_chunk: Vec<(f64, &PriceEdge, &PriceEdge, &PriceEdge, &String, &String, &String)> = chunk
                    .iter()
                    .map(|(p1, p2, p3, f1, f2, f3, token_a, token_b, token_c, edge_a, edge_b, edge_c)| {
                        let profit = if is_simd_available() {
                            let prices = [*p1, *p2, *p3];
                            let fees = [*f1, *f2, *f3];
                            calculate_triangular_profit_simd(&prices, &fees)
                        } else {
                            (1.0 / p1) * (1.0 / p2) * (1.0 / p3) -
                            (*f1 + *f2 + *f3)
                        };
                        (profit, *edge_a, *edge_b, *edge_c, *token_a, *token_b, *token_c)
                    })
                    .filter(|(profit, _, _, _, _, _, _)| {
                        profit > &mut (self.config.min_profit_threshold / 100.0)
                    })
                    .collect();

                // Create full opportunity objects for profitable candidates
                for (profit, edge_a, edge_b, edge_c, token_a, token_b, token_c) in opportunities_for_chunk {
                    let liquidity_score = edge_a.liquidity.min(edge_b.liquidity).min(edge_c.liquidity);
                    let confidence_score = self.calculate_confidence_score(token_a, token_b, token_c);
                    let slippage_estimate = self.estimate_slippage(&[edge_a, edge_b, edge_c]);
                    let estimated_gas_cost = 0.005;

                    if slippage_estimate <= self.config.max_slippage &&
                       liquidity_score >= self.config.min_liquidity &&
                       confidence_score >= self.config.confidence_threshold &&
                       estimated_gas_cost <= self.config.max_gas_price {

                        opportunities.push(TriangularOpportunity {
                            cycle: vec![
                                token_a.to_string(),
                                token_b.to_string(),
                                token_c.to_string(),
                                token_a.to_string(),
                            ],
                            dexes: vec![
                                edge_a.dex_name.clone(),
                                edge_b.dex_name.clone(),
                                edge_c.dex_name.clone(),
                            ],
                            prices: vec![edge_a.price, edge_b.price, edge_c.price],
                            profit_percentage: profit * 100.0,
                            estimated_gas_cost,
                            liquidity_score,
                            confidence_score,
                            timestamp,
                            slippage_estimate,
                        });
                    }
                }
            }

            opportunities
        } else {
            // Fallback to scalar processing
            let mut opportunities = Vec::new();
            for (token_a, token_b, token_c, edge_a, edge_b, edge_c) in candidates {
                if let Some(opp) = self.calculate_triangular_opportunity(
                    token_a, token_b, token_c, edge_a, edge_b, edge_c, timestamp
                ) {
                    if self.is_opportunity_valid(&opp) {
                        opportunities.push(opp);
                    }
                }
            }
            opportunities
        }
    }

    fn is_opportunity_valid(&self, opportunity: &TriangularOpportunity) -> bool {
        opportunity.profit_percentage >= self.config.min_profit_threshold
            && opportunity.slippage_estimate <= self.config.max_slippage
            && opportunity.liquidity_score >= self.config.min_liquidity
            && opportunity.confidence_score >= self.config.confidence_threshold
            && opportunity.estimated_gas_cost <= self.config.max_gas_price
    }

    // Getters for current opportunities
    pub fn get_triangular_opportunities(&self) -> Vec<TriangularOpportunity> {
        self.active_opportunities.lock().unwrap().clone()
    }

    pub fn get_cross_dex_opportunities(&self) -> Vec<CrossDexOpportunity> {
        self.cross_dex_opportunities.lock().unwrap().clone()
    }

    pub fn get_statistical_opportunities(&self) -> Vec<StatisticalOpportunity> {
        self.statistical_opportunities.lock().unwrap().clone()
    }

    pub fn get_token_info(&self, address: &str) -> Option<&TokenInfo> {
        self.token_registry.get(address)
    }

    pub fn get_price_model(&self, address: &str) -> Option<&PriceModel> {
        self.price_models.get(address)
    }

    pub fn update_config(&mut self, config: ArbitrageConfig) {
        self.config = config;
        info!("Arbitrage engine configuration updated");
    }

    pub fn get_status(&self) -> ArbitrageStatus {
        let last_scan = *self.last_scan.lock().unwrap();
        let is_running = *self.is_running.lock().unwrap();

        ArbitrageStatus {
            is_running,
            last_scan,
            registered_tokens: self.token_registry.len(),
            triangular_opportunities: self.get_triangular_opportunities().len(),
            cross_dex_opportunities: self.get_cross_dex_opportunities().len(),
            statistical_opportunities: self.get_statistical_opportunities().len(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ArbitrageStatus {
    pub is_running: bool,
    pub last_scan: Instant,
    pub registered_tokens: usize,
    pub triangular_opportunities: usize,
    pub cross_dex_opportunities: usize,
    pub statistical_opportunities: usize,
}

// Async scanner service
pub struct ArbitrageScanner {
    engine: Arc<AsyncRwLock<ArbitrageEngine>>,
    handle: Option<tokio::task::JoinHandle<()>>,
}

impl ArbitrageScanner {
    pub fn new(engine: Arc<AsyncRwLock<ArbitrageEngine>>) -> Self {
        Self {
            engine,
            handle: None,
        }
    }

    pub async fn start(&mut self) -> Result<()> {
        if self.handle.is_some() {
            warn!("Arbitrage scanner is already running");
            return Ok(());
        }

        let engine_clone = self.engine.clone();
        let mut interval = interval(
            engine_clone.read().await.config.scan_interval
        );

        self.handle = Some(tokio::spawn(async move {
            loop {
                interval.tick().await;

                let mut engine = engine_clone.write().await;
                match engine.scan_arbitrage_opportunities().await {
                    Ok(count) => {
                        if count > 0 {
                            info!("Found {} arbitrage opportunities", count);
                        }
                    }
                    Err(e) => {
                        error!("Error scanning arbitrage opportunities: {}", e);
                    }
                }
            }
        }));

        info!("Arbitrage scanner started");
        Ok(())
    }

    pub async fn stop(&mut self) -> Result<()> {
        if let Some(handle) = self.handle.take() {
            handle.abort();
            info!("Arbitrage scanner stopped");
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_arbitrage_engine_basic() {
        let config = ArbitrageConfig::default();
        let mut engine = ArbitrageEngine::new(config);

        // Register some test tokens
        let sol_token = TokenInfo {
            address: "So11111111111111111111111111111111111111112".to_string(),
            symbol: "SOL".to_string(),
            name: "Solana".to_string(),
            decimals: 9,
            verified: true,
        };

        let usdc_token = TokenInfo {
            address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v".to_string(),
            symbol: "USDC".to_string(),
            name: "USD Coin".to_string(),
            decimals: 6,
            verified: true,
        };

        engine.register_token(sol_token);
        engine.register_token(usdc_token);

        // Test scanning
        let count = engine.scan_arbitrage_opportunities().await.unwrap();
        assert_eq!(count, 0); // No opportunities with no price data
    }

    #[test]
    fn test_price_model() {
        let mut model = PriceModel::new("test".to_string(), 10);

        // Add some test prices
        for i in 0..10 {
            model.update(100.0 + i as f64, i as i64);
        }

        assert_eq!(model.prices.len(), 10);
        assert!(model.mean > 100.0);
        assert!(model.variance > 0.0);
    }
}