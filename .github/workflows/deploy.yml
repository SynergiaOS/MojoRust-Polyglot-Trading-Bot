name: Deploy

on:
  push:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      mode:
        description: 'Trading mode'
        required: true
        default: 'paper'
        type: choice
        options:
        - paper
        - live
      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: false
        type: boolean
  release:
    types: [published]

env:
  DEPLOY_PACKAGE_NAME: mojorust-deploy

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      commit_sha: ${{ steps.meta.outputs.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract version
        id: version
        run: |
          if [ -f mojo.toml ]; then
            VERSION=$(python3 -c "
import toml
try:
    data = toml.load(open('mojo.toml'))
    print(data.get('package', {}).get('version', 'unknown'))
except:
    print('unknown')
            ")
          else
            VERSION="unknown"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Extract metadata
        id: meta
        run: |
          echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "ref=${{ github.ref_name }}" >> $GITHUB_OUTPUT

      - name: Install GitHub CLI
        run: |
          curl -fsSL https://cli.github.com/packages/github-cli.sh | sh

    - name: Check CI workflow status
        run: |
          # Wait for CI to complete
          sleep 30

          # Check CI workflow
          CI_STATUS=$(gh api repos/${{ github.repository }}/actions/runs \
            --jq '.workflow_runs | map(select(.head_sha == "${{ github.sha }}" and .name == "CI")) | .[0].conclusion')

          if [[ "$CI_STATUS" != "success" ]]; then
            echo "âŒ CI workflow did not pass (status: $CI_STATUS)"
            echo "Please ensure all CI checks pass before deployment"
            exit 1
          fi

          echo "âœ… CI workflow passed"

      - name: Validate Configuration
        run: |
          # Check if validation script exists
          if [ -f "scripts/validate_config.sh" ]; then
            scripts/validate_config.sh --env-file .env.production.example --strict
          else
            echo "âš ï¸  Configuration validation script not found, performing basic validation"

            # Basic configuration validation
            if [ -f ".env.production.example" ]; then
              echo "âœ… Production environment template found"

              # Check for required environment variables
              required_vars=("HELIUS_API_KEY" "QUICKNODE_RPC_URL" "INFISICAL_PROJECT_ID")
              missing_vars=()

              for var in "${required_vars[@]}"; do
                if ! grep -q "^${var}=" .env.production.example; then
                  missing_vars+=("$var")
                fi
              done

              if [ ${#missing_vars[@]} -gt 0 ]; then
                echo "âŒ Missing required environment variables: ${missing_vars[*]}"
                exit 1
              else
                echo "âœ… All required environment variables found in template"
              fi
            else
              echo "âŒ Production environment template not found"
              exit 1
            fi
          fi

      - name: Validate API Dependencies
        run: |
          echo "ðŸ” Validating API dependencies and connectivity..."

          # Check if API placeholder handler is properly implemented
          if [ -f "src/core/api_placeholder_handler.mojo" ]; then
            echo "âœ… API placeholder handler found"
          else
            echo "âŒ API placeholder handler not found"
            exit 1
          fi

          # Check if placeholder detector is implemented
          if [ -f "src/core/placeholder_detector.mojo" ]; then
            echo "âœ… Placeholder detector found"
          else
            echo "âŒ Placeholder detector not found"
            exit 1
          fi

          # Verify critical Mojo files can be parsed (syntax check)
          critical_files=("src/main.mojo" "src/data/enhanced_data_pipeline.mojo" "src/execution/ultimate_executor.mojo")

          for file in "${critical_files[@]}"; do
            if [ -f "$file" ]; then
              echo "âœ… Critical file found: $file"
              # Basic syntax check (if Mojo provides a way to validate syntax)
              # For now, just check if file is not empty and has basic structure
              if [ -s "$file" ] && grep -q "fn" "$file"; then
                echo "âœ… File structure appears valid: $file"
              else
                echo "âš ï¸  File may have issues: $file"
              fi
            else
              echo "âŒ Critical file missing: $file"
              exit 1
            fi
          done

      - name: Validate Placeholder Configuration
        run: |
          echo "ðŸ”‘ Validating placeholder detection configuration..."

          # Check environment template for placeholder patterns
          if [ -f ".env.production.example" ]; then
            echo "âœ… Production environment template found"

            # Check for obvious placeholder patterns
            PLACEHOLDER_COUNT=$(grep -c "your_.*\(key\|api\|token\|secret\)" .env.production.example || echo "0")
            if [[ "$PLACEHOLDER_COUNT" -gt 0 ]]; then
              echo "âš ï¸  Found $PLACEHOLDER_COUNT placeholder API keys in template"
              echo "   This is expected for development templates"
            fi

            # Check for critical API variables
            CRITICAL_VARS=("HELIUS_API_KEY" "QUICKNODE_RPC_URL" "INFISICAL_PROJECT_ID")
            MISSING_CRITICAL=()

            for var in "${CRITICAL_VARS[@]}"; do
              if grep -q "^${var}=" .env.production.example; then
                echo "âœ… Critical variable template found: $var"
              else
                MISSING_CRITICAL+=("$var")
              fi
            done

            if [[ ${#MISSING_CRITICAL[@]} -gt 0 ]]; then
              echo "âŒ Missing critical variable templates: ${MISSING_CRITICAL[*]}"
              exit 1
            fi
          else
            echo "âŒ Production environment template not found"
            exit 1
          fi

          # Test placeholder detection logic (basic test)
          echo "ðŸ§ª Testing placeholder detection logic..."

          # Test basic placeholder detection patterns
          if grep -q "your_.*_key" .env.production.example; then
            echo "âœ… Placeholder detection patterns found in environment template"
          fi

          # Validate that graceful fallback is implemented in core files
          FALLBACK_FILES=("src/core/api_placeholder_handler.mojo" "src/arbitrage/arbitrage_detector.mojo")

          for file in "${FALLBACK_FILES[@]}"; do
            if [ -f "$file" ]; then
              if grep -q "fallback" "$file"; then
                echo "âœ… Graceful fallback implemented in: $file"
              else
                echo "âš ï¸  Fallback patterns not found in: $file"
              fi
            fi
          done

          echo "âœ… Placeholder configuration validation completed"

  package:
    runs-on: ubuntu-latest
    needs: validate
    outputs:
      package_name: ${{ steps.package.outputs.PACKAGE_NAME }}
      package_file: ${{ steps.package.outputs.PACKAGE_FILE }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Mojo
        env:
          MODULAR_AUTH_TOKEN: ${{ secrets.MODULAR_AUTH_TOKEN }}
        run: |
          curl -fsSL https://get.modular.com | sh -s -- --skip-license-prompt
          mkdir -p ~/.modular
          echo "token = \"$MODULAR_AUTH_TOKEN\"" > ~/.modular/auth.toml
          modular install mojo
          echo "$HOME/.modular/pkg/packages.modular.com_mojo/bin" >> $GITHUB_PATH
          mojo --version

      - name: Build Application
        run: |
          mkdir -p target
          mojo build src/main.mojo -o target/trading-bot
          mojo build src/main_ultimate.mojo -o target/trading-bot-ultimate
          chmod +x target/trading-*

      - name: Build Rust Modules
        run: |
          cd rust-modules
          cargo build --release --all-features

      - name: Create Deployment Package
        run: |
          VERSION="${{ needs.validate.outputs.version }}"
          SHA="${{ needs.validate.outputs.commit_sha }}"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          PACKAGE_NAME="${{ env.DEPLOY_PACKAGE_NAME }}-${VERSION}-${SHA:0:8}"
          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_OUTPUT
          echo "PACKAGE_FILE=${PACKAGE_NAME}.tar.gz" >> $GITHUB_OUTPUT

          mkdir -p deploy-package

          # Include source files
          cp -r src/ deploy-package/
          cp -r scripts/ deploy-package/
          cp -r config/ deploy-package/
          cp -r rust-modules/ deploy-package/
          cp -r tests/ deploy-package/

          # Include configuration files
          cp mojo.toml deploy-package/
          cp *.md deploy-package/ 2>/dev/null || true
          cp .env.production.example deploy-package/
          cp docker-compose.yml deploy-package/ 2>/dev/null || true

          # Include pre-built binaries
          cp -r target/ deploy-package/

          # Create deployment manifest
          cat > deploy-package/deployment-manifest.json << EOF
          {
            "version": "$VERSION",
            "commit_sha": "$SHA",
            "build_timestamp": "$TIMESTAMP",
            "environment": "${{ github.event.inputs.environment || github.ref_name }}",
            "mode": "${{ github.event.inputs.mode || 'paper' }}",
            "deployed_by": "${{ github.actor }}",
            "repo": "${{ github.repository }}",
            "ref": "${{ github.ref_name }}"
          }
          EOF

          # Create tarball
          tar -czf "${PACKAGE_NAME}.tar.gz" -C deploy-package .

      - name: Upload Deployment Package
        uses: actions/upload-artifact@v3
        with:
          name: deployment-package
          path: ${{ steps.package.outputs.PACKAGE_FILE }}
          retention-days: 30

  deploy-staging:
    runs-on: ubuntu-latest
    needs: [validate, package]
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment: staging
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Deployment Package
        uses: actions/download-artifact@v3
        with:
          name: deployment-package
          path: .

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan ${{ secrets.STAGING_SERVER_IP }} >> ~/.ssh/known_hosts

      - name: Test SSH Connection
        run: |
          ssh -o ConnectTimeout=10 ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SERVER_IP }} "echo 'SSH connection successful'"

      - name: Deploy to Staging
        run: |
          PACKAGE_FILE="${{ needs.package.outputs.package_file }}"
          PACKAGE_NAME="${{ needs.package.outputs.package_name }}"
          STAGING_USER="${{ secrets.STAGING_SSH_USER }}"
          STAGING_SERVER="${{ secrets.STAGING_SERVER_IP }}"

          echo "ðŸš€ Deploying $PACKAGE_NAME to staging server..."

          # Upload package
          scp "$PACKAGE_FILE" "${STAGING_USER}@${STAGING_SERVER}:/tmp/"

          # Deploy on staging server
          ssh "${STAGING_USER}@${STAGING_SERVER}" "
            set -e

            # Create deployment directory
            sudo mkdir -p /opt/mojorust-staging
            cd /opt/mojorust-staging

            # Backup current deployment
            if [ -d 'current' ]; then
              sudo mv current backup-\$(date +%Y%m%d-%H%M%S)
            fi

            # Extract new deployment
            sudo rm -rf current
            sudo mkdir current
            sudo tar -xzf '/tmp/${PACKAGE_FILE}' -C current

            # Set permissions
            sudo chown -R ${STAGING_USER}:${STAGING_USER} current/
            sudo chmod +x current/target/trading-bot*
            sudo chmod +x current/scripts/*.sh

            # Configure environment (staging always uses paper mode)
            sudo cp current/.env.production.example current/.env
            echo 'EXECUTION_MODE=paper' | sudo tee -a current/.env
            echo 'TRADING_ENV=staging' | sudo tee -a current/.env

            # Set environment variables
            echo 'HELIUS_API_KEY=${{ secrets.HELIUS_API_KEY }}' | sudo tee -a current/.env
            echo 'QUICKNODE_RPC_URL=${{ secrets.QUICKNODE_RPC_URL }}' | sudo tee -a current/.env
            echo 'INFISICAL_PROJECT_ID=${{ secrets.INFISICAL_PROJECT_ID }}' | sudo tee -a current/.env
            echo 'INFISICAL_CLIENT_ID=${{ secrets.INFISICAL_CLIENT_ID }}' | sudo tee -a current/.env
            echo 'INFISICAL_CLIENT_SECRET=${{ secrets.INFISICAL_CLIENT_SECRET }}' | sudo tee -a current/.env

            # Stop existing bot
            sudo pkill -f trading-bot || true
            sleep 5

            # Start new bot
            cd current
            nohup ./target/trading-bot --mode=paper > logs/staging-bot.log 2>&1 &

            echo 'âœ… Deployment completed'
          "

      - name: Health Check
        run: |
          echo "â³ Waiting for bot to start..."
          sleep 60

          # Check if bot is running
          SSH_RESULT=$(ssh ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SERVER_IP }} "pgrep -f trading-bot || echo 'not_found'")

          if [[ "$SSH_RESULT" == "not_found" ]]; then
            echo "âŒ Bot is not running"
            ssh ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SERVER_IP }} "tail -n 50 /opt/mojorust-staging/current/logs/staging-bot.log"
            exit 1
          fi

          echo "âœ… Bot is running (PID: $SSH_RESULT)"

          # Check logs for errors
          ssh ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SERVER_IP }} "tail -n 20 /opt/mojorust-staging/current/logs/staging-bot.log" | grep -i error && echo "âš ï¸ Found errors in logs" || echo "âœ… No errors found in recent logs"

  deploy-production:
    runs-on: ubuntu-latest
    needs: [validate, package]
    if: github.ref == 'refs/heads/main' || github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment: production
    steps:
      - name: Pre-deployment Confirmation
        run: |
          echo "ðŸš€ Preparing for PRODUCTION deployment"
          echo "Version: ${{ needs.validate.outputs.version }}"
          echo "Commit: ${{ needs.validate.outputs.commit_sha }}"
          echo "Mode: ${{ github.event.inputs.mode || 'paper' }}"
          echo ""
          echo "âš ï¸  This will deploy to PRODUCTION server (38.242.239.150)"
          echo "âš ï¸  Ensure you have reviewed the changes"

      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Deployment Package
        uses: actions/download-artifact@v3
        with:
          name: deployment-package

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan 38.242.239.150 >> ~/.ssh/known_hosts

      - name: Test SSH Connection
        run: |
          ssh -o ConnectTimeout=10 root@38.242.239.150 "echo 'SSH connection successful'"

      - name: Create Backup
        run: |
          echo "ðŸ“¦ Creating backup of current production deployment..."
          ssh root@38.242.239.150 "
            set -e
            BACKUP_DIR='/root/mojorust-backups'
            TIMESTAMP=\$(date +%Y%m%d-%H%M%S)
            BACKUP_PATH='\${BACKUP_DIR}/production-backup-\${TIMESTAMP}'

            sudo mkdir -p '\${BACKUP_DIR}'

            if [ -d '/root/mojorust' ]; then
              sudo cp -r /root/mojorust '\${BACKUP_PATH}'
              echo 'âœ… Backup created: \${BACKUP_PATH}'
            else
              echo 'âš ï¸  No existing deployment to backup'
            fi
          "

      - name: Deploy to Production
        run: |
          PACKAGE_FILE="${{ needs.package.outputs.package_file }}"
          PACKAGE_NAME="${{ needs.package.outputs.package_name }}"
          DEPLOY_MODE="${{ github.event.inputs.mode || 'paper' }}"

          echo "ðŸš€ Deploying $PACKAGE_NAME to PRODUCTION server..."
          echo "Mode: $DEPLOY_MODE"

          # Upload package
          scp "$PACKAGE_FILE" root@38.242.239.150:/tmp/

          # Deploy on production server
          ssh root@38.242.239.150 "
            set -e

            # Create deployment directory
            mkdir -p /root/mojorust
            cd /root/mojorust

            # Stop current bot gracefully
            echo 'ðŸ›‘ Stopping current bot...'
            pkill -SIGTERM -f trading-bot || true
            sleep 10
            pkill -9 -f trading-bot || true

            # Extract new deployment
            echo 'ðŸ“¦ Extracting new deployment...'
            tar -xzf '/tmp/${PACKAGE_FILE}' --strip-components=1

            # Set permissions
            chmod +x target/trading-bot*
            chmod +x scripts/*.sh

            # Configure environment
            cp .env.production.example .env
            echo 'EXECUTION_MODE=${DEPLOY_MODE}' >> .env
            echo 'TRADING_ENV=production' >> .env

            # Set production environment variables
            echo 'HELIUS_API_KEY=${{ secrets.HELIUS_API_KEY }}' >> .env
            echo 'QUICKNODE_RPC_URL=${{ secrets.QUICKNODE_RPC_URL }}' >> .env
            echo 'INFISICAL_PROJECT_ID=${{ secrets.INFISICAL_PROJECT_ID }}' >> .env
            echo 'INFISICAL_CLIENT_ID=${{ secrets.INFISICAL_CLIENT_ID }}' >> .env
            echo 'INFISICAL_CLIENT_SECRET=${{ secrets.INFISICAL_CLIENT_SECRET }}' >> .env
            echo 'TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}' >> .env
            echo 'TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_CHAT_ID }}' >> .env

            # Start new bot
            echo 'ðŸš€ Starting new bot...'
            mkdir -p logs
            nohup ./target/trading-bot --mode=${DEPLOY_MODE} > logs/production-bot.log 2>&1 &

            echo 'âœ… Deployment completed'
          "

      - name: Enhanced Health Check with Rollback
        run: |
          echo "â³ Waiting for bot to start..."
          sleep 120

          # Check if bot is running
          SSH_RESULT=$(ssh root@38.242.239.150 "pgrep -f trading-bot || echo 'not_found'")

          if [[ "$SSH_RESULT" == "not_found" ]]; then
            echo "âŒ Bot is not running - triggering automatic rollback"

            # Find latest backup
            LATEST_BACKUP=$(ssh root@38.242.239.150 "
              BACKUP_DIR='/root/mojorust-backups'
              if [ -d '\$BACKUP_DIR' ]; then
                ls -t '\$BACKUP_DIR' | head -1
              else
                echo 'none'
              fi
            ")

            if [[ "$LATEST_BACKUP" != "none" ]]; then
              echo "ðŸ”„ Rolling back to: $LATEST_BACKUP"
              ssh root@38.242.239.150 "
                set -e
                BACKUP_DIR='/root/mojorust-backups'
                LATEST_BACKUP='$LATEST_BACKUP'

                # Stop failed deployment
                pkill -SIGTERM -f trading-bot || true
                sleep 5
                pkill -9 -f trading-bot || true

                # Restore from backup
                cd /root
                rm -rf mojorust
                cp -r '\${BACKUP_DIR}/\${LATEST_BACKUP}' mojorust
                cd mojorust

                # Start restored bot
                nohup ./target/trading-bot --mode=paper > logs/rollback-bot.log 2>&1 &

                echo 'âœ… Rollback completed'
              "

              # Verify rollback
              sleep 30
              ROLLBACK_RESULT=$(ssh root@38.242.239.150 "pgrep -f trading-bot || echo 'not_found'")
              if [[ "$ROLLBACK_RESULT" != "not_found" ]]; then
                echo "âœ… Rollback successful - bot is running"
              else
                echo "âŒ Rollback failed - manual intervention required"
              fi
            else
              echo "âŒ No backup available for rollback"
            fi

            ssh root@38.242.239.150 "tail -n 100 logs/production-bot.log"
            exit 1
          fi

          echo "âœ… Bot is running (PID: $SSH_RESULT)"

          # Enhanced log checking
          ERROR_COUNT=$(ssh root@38.242.239.150 "tail -n 100 logs/production-bot.log | grep -ic error || echo '0'")
          CRITICAL_COUNT=$(ssh root@38.242.239.150 "tail -n 100 logs/production-bot.log | grep -ic critical || echo '0'")

          if [[ "$ERROR_COUNT" -gt 10 ]]; then
            echo "âš ï¸ High error count detected: $ERROR_COUNT errors"
          elif [[ "$CRITICAL_COUNT" -gt 0 ]]; then
            echo "âš ï¸ Critical errors detected: $CRITICAL_COUNT critical errors"
          else
            echo "âœ… No significant errors found in recent logs"
          fi

      - name: Smoke Tests
        run: |
          echo "ðŸ” Running smoke tests..."

          # Test health endpoint (if available)
          if curl -f http://38.242.239.150:8080/api/health >/dev/null 2>&1; then
            echo "âœ… Health endpoint responding"
          else
            echo "âš ï¸ Health endpoint not responding (may be starting up)"
          fi

          # Verify bot process
          SSH_RESULT=$(ssh root@38.242.239.150 "pgrep -f trading-bot")
          if [[ -n "$SSH_RESULT" ]]; then
            echo "âœ… Bot process verified"
          else
            echo "âŒ Bot process not found"
            exit 1
          fi

  post-deploy:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    steps:
      - name: Deployment Summary
        run: |
          echo "# Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Environment: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "## Version: ${{ needs.validate.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "## Commit: ${{ needs.validate.outputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "## Mode: ${{ github.event.inputs.mode || 'paper' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "âœ… Staging deployment successful" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            echo "âœ… Production deployment successful" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.deploy-production.result }}" == "failure" ]]; then
            echo "âŒ Production deployment failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Send Notification (Optional)
        if: env.TELEGRAM_BOT_TOKEN != ''
        run: |
          # Send deployment notification to Telegram
          MESSAGE="ðŸš€ MojoRust Trading Bot Deployment

          Environment: ${{ github.ref_name }}
          Version: ${{ needs.validate.outputs.version }}
          Mode: ${{ github.event.inputs.mode || 'paper' }}
          Status: ${{ job.status }}

          Deployed by: ${{ github.actor }}"

          curl -X POST \
            "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML"
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        continue-on-error: true